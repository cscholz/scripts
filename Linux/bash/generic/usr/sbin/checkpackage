#!/bin/bash
# Version=20251009.04
# Ensure an executable exists; if missing, ask once and then install the given package non-interactively.

set -euo pipefail

# -------------------------
# Colors & formatting
# -------------------------
RED='\e[0;31m'
GREEN='\e[0;32m'
YELLOW='\e[0;33m'
NC='\e[0m'
BOLD='\e[1m'
NOBOLD='\e[0m'
CHECKMARK="✓"
CROSSMARK="✗"

# -------------------------
# Script & config paths
# -------------------------
SCRIPT_NAME="$(basename "$0")"
CONFIG_NAME="${SCRIPT_NAME%.sh}.conf"
GLOBAL_CONFIG="/etc/${CONFIG_NAME}"
USER_CONFIG="$HOME/.config/${CONFIG_NAME}"

# -------------------------
# Logging helpers
# -------------------------
log_status() {
  local msg="$1"
  local newline="${2:-0}" # 0 = no newline, 1 = newline
  if [[ "$newline" == "1" ]]; then
    echo -e "\r$msg"
  else
    echo -ne "\r$msg"
  fi
}

debug=0
debug_msg() {
  if [[ "$debug" == "1" ]]; then
    log_status "  ${YELLOW}\$ $*${NC}" 1
  fi
}

# -------------------------
# Config permission check
# -------------------------
check_config_permissions() {
  local cfg="$1"
  if [[ -f "$cfg" ]]; then
    local mode
    mode=$(stat -c "%a" "$cfg")
    if [[ "$mode" != "600" ]]; then
      log_status "[${RED}${CROSSMARK}${NC}] Config file $cfg must have permissions 0600, but has $mode" 1
      exit 10
    fi
  fi
}

# Load configs (global then user)
config_loaded=false
if [[ -f "$GLOBAL_CONFIG" ]]; then
  check_config_permissions "$GLOBAL_CONFIG"
  source "$GLOBAL_CONFIG"
  config_loaded=true
fi
if [[ -f "$USER_CONFIG" ]]; then
  check_config_permissions "$USER_CONFIG"
  source "$USER_CONFIG"
  config_loaded=true
fi

# -------------------------
# Self-update (optional)
# -------------------------
run_self_update() {
  local self="$1"
  local update_base="${2:-${UPDATE_BASE:-https://to_be_set/}}"
  local script_path
  script_path=$(realpath "$0" 2>/dev/null || echo "$0")
  local script_name
  script_name=$(basename "$script_path")

  echo "Performing self-update"

  echo -ne "\r[ ] Downloading latest version..."
  if ! wget --quiet --output-document="${script_name}.tmp" "${update_base}/${self}"; then
    echo -e "\r[${RED}✗${NC}] Downloading latest version"
    echo "[${RED}✗${NC}] Performing self-update"
    exit 1
  fi
  echo -e "\r[${GREEN}✓${NC}] Downloading latest version"

  echo -ne "\r[ ] Copying over modes from old version..."
  local octal_mode
  octal_mode=$(stat -c '%a' "$script_path" 2>/dev/null || echo "755")
  if ! chmod "$octal_mode" "${script_name}.tmp"; then
    echo -e "\r[${RED}✗${NC}] Copying over modes from old version"
    echo "[${RED}✗${NC}] Performing self-update"
    exit 1
  fi
  echo -e "\r[${GREEN}✓${NC}] Copying over modes from old version"

  echo -ne "\r[ ] Start update process..."
  cat > updateScript.sh <<'EOF'
#!/bin/bash
script_name="$(basename "${0}")"
target="${script_name}"
if mv "${target}.tmp" "${target}"; then
  printf "\r\033[0KUpdate complete.\n"
  rm -f "${0}"
else
  printf "\r\033[0KUpdate failed. Please try again!\n"
  rm -f "${0}"
fi
EOF
  chmod +x updateScript.sh
  exec /bin/bash updateScript.sh
}

check_self_update() {
  local self
  self=$(basename "${0}")

  # Config required
  if [[ "$config_loaded" == false ]]; then
    log_status "[${RED}${CROSSMARK}${NC}] No config file found. Cannot perform self-update." 1
    exit 10
  fi

  local update_base="${UPDATE_BASE:-https://to_be_set/}"
  local myself_web_version
  myself_web_version=$(curl -s -r 0-50 "${update_base}${self}" | head -2 | grep -E -o "([0-9]{8}\.[0-9]{2})")
  log_status "Web version: ${myself_web_version}" 1
  local myself_local_version
  myself_local_version=$(head -n 3 "${0}" | grep -E -o "([0-9]{8}\.[0-9]{2})" | head -n1)
  log_status "Local version: ${myself_local_version}" 1
  if [[ -n "${myself_web_version}" && "${myself_web_version}"  > "${myself_local_version}" ]]; then
    log_status "${YELLOW}New version v.${myself_local_version} to v.${myself_web_version} available.${NC}" 1
    read -p "Update [y/N] " -r
    echo
    if [[ ${REPLY:-N} =~ ^[Yy]$ ]]; then
      run_self_update "${self}" "${update_base}"
    fi
  else
    log_status "No update available: v.${myself_local_version}" 1
  fi
}

# -------------------------
# Distro detection & install
# -------------------------
detect_distro() {
  local id like
  if [[ -r /etc/os-release ]]; then
    # shellcheck disable=SC1091
    . /etc/os-release
    id="${ID:-}"; like="${ID_LIKE:-}"
    if [[ "$id" =~ (debian|ubuntu) || "$like" =~ debian ]]; then
      echo debian; return
    fi
    if [[ "$id" =~ (opensuse|suse|sles) || "$like" =~ suse ]]; then
      echo suse; return
    fi
    if [[ "$id" =~ arch || "$like" =~ arch ]]; then
      echo arch; return
    fi
  fi
  if command -v apt-get >/dev/null 2>&1; then echo debian; return; fi
  if command -v zypper  >/dev/null 2>&1; then echo suse;   return; fi
  if command -v pacman  >/dev/null 2>&1; then echo arch;   return; fi
  echo unknown
}

install_package() {
  local distro="$1"
  local pkg="$2"
  case "$distro" in
    debian)
      export DEBIAN_FRONTEND=noninteractive
      sudo apt-get update -y
      sudo apt-get install -y "$pkg"
      ;;
    suse)
      sudo zypper --non-interactive install -y "$pkg"
      ;;
    arch)
      sudo pacman -Sy --noconfirm "$pkg"
      ;;
    *)
      log_status "[${RED}${CROSSMARK}${NC}] Unsupported distribution for auto-install." 1
      exit 2
      ;;
  esac
}

# -------------------------
# Usage / help
# -------------------------
print_usage() {
  echo -e "${BOLD}Usage:${NOBOLD} ${SCRIPT_NAME} [options] <executable> <package>"
  echo
  echo "Checks if <executable> exists (via 'which'). If not, asks once:"
  echo "\"Package \\\"<package>\\\" not found! Install? (y/N)\""
  echo "If yes, installs <package> non-interactively using the distro's package manager"
  echo "(Debian/Ubuntu: apt-get, openSUSE: zypper, Arch: pacman)."
  echo
  echo -e "${BOLD}Options:${NOBOLD}"
  echo "  -v            Enable debug output"
  echo "  -h            Show this help"
  echo "  -u            Self-update"
  echo
  echo -e "${BOLD}Example:${NOBOLD}"
  echo "  ${SCRIPT_NAME} nsupdate dnsutils"
}

# -------------------------
# Arg parsing
# -------------------------
while getopts ":vhu" opt; do
  case "$opt" in
    v) debug=1 ;;
    h) print_usage; exit 0 ;;
    u) check_self_update; exit 0 ;;
    \?) echo -e "${RED}Unknown option: -$OPTARG${NC}"; print_usage; exit 2 ;;
  esac
done
shift $((OPTIND - 1))

# Require 2 args
if [[ $# -lt 2 ]]; then
  print_usage
  exit 1
fi

EXEC_NAME="$1"
PKG_NAME="$2"

# -------------------------
# Check presence
# -------------------------
if which "$EXEC_NAME" >/dev/null 2>&1; then
  exit 0
fi

# Ask once (interactive)
echo -e "Package \"${PKG_NAME}\" not found! Install? (y/N) \c"
read -r REPLY
if [[ -z "${REPLY}" ]]; then
  REPLY="n"
fi
if [[ "${REPLY}" != "y" && "${REPLY}" != "Y" ]]; then
  exit 0
fi

# Install
DISTRO="$(detect_distro)"
log_status "[ ] Installing '${PKG_NAME}' for missing '${EXEC_NAME}' on ${DISTRO}..."
install_package "$DISTRO" "$PKG_NAME" >/dev/null 2>&1 && \
  log_status "\r[${GREEN}${CHECKMARK}${NC}] Installed '${PKG_NAME}'" 1 || \
  { log_status "\r[${RED}${CROSSMARK}${NC}] Failed installing '${PKG_NAME}'" 1; exit 3; }

# Verify
if which "$EXEC_NAME" >/dev/null 2>&1; then
  exit 0
else
  log_status "[${RED}${CROSSMARK}${NC}] '${EXEC_NAME}' still not found after installation." 1
  exit 4
fi

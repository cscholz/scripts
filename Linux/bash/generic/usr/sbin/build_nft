#!/bin/bash
#
# build_nft.sh - Optimized NFTables Configuration Builder
# Version: 2.0 - 2025-10-30
#
# This script resolves domain names in nftables configuration files and builds
# a production-ready configuration with IP addresses.
#
# Features:
# - DNS resolution with timeout and retry logic
# - Automatic backup and rollback capability
# - Syntax validation before loading
# - Atomic firewall reload (no security gap)
# - Rate limiting for DNS queries
# - Lock mechanism to prevent concurrent runs
# - Comprehensive logging
# - Emerging Threats integration (fixed)
#
# Usage: ./build_nft.sh <input_file> <output_file>
#

set -euo pipefail  # Exit on error, undefined vars, pipe failures

#######################################
# Configuration
#######################################

readonly VERSION="2.0.20251030"
readonly SCRIPT_NAME="$(basename "$0")"

# DNS Configuration
readonly DIG_TIMEOUT=5          # Seconds to wait for DNS response
readonly DIG_RETRIES=3          # Number of retry attempts
readonly DNS_DELAY=0.1          # Delay between DNS queries (rate limiting)
readonly DNS_PARALLEL=false     # Set to true for parallel DNS resolution (experimental)

# File Paths
readonly BACKUP_DIR="/var/backups/nftables"
readonly LOCKFILE="/var/lock/build_nft.lock"
readonly LOGFILE="/var/log/build_nft.log"

# nftables paths
readonly NFT_BIN="/usr/sbin/nft"
readonly SYSTEMCTL_BIN="/usr/bin/systemctl"

# Behavior flags
readonly LOAD_EMERGING_THREATS=true  # Load Emerging Threats blocklists
readonly AUTO_ROLLBACK=true          # Automatically rollback on failure

#######################################
# Colors and Formatting
#######################################

if [[ -t 1 ]] && [[ "$TERM" != "dumb" ]]; then
    readonly RED='\033[0;31m'
    readonly GREEN='\033[0;32m'
    readonly YELLOW='\033[1;33m'
    readonly BLUE='\033[0;34m'
    readonly NC='\033[0m' # No Color
else
    readonly RED=''
    readonly GREEN=''
    readonly YELLOW=''
    readonly BLUE=''
    readonly NC=''
fi

#######################################
# Global Variables
#######################################

declare -a FAILED_DOMAINS=()
declare -i RESOLVED_COUNT=0
declare -i TOTAL_DOMAINS=0
declare TEMP_OUTPUT=""
declare LAST_WORKING_CONFIG=""

#######################################
# Logging Functions
#######################################

log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
    
    echo "[$timestamp] [$level] $message" | tee -a "$LOGFILE"
}

log_info() {
    echo -e "[i] $*" | tee -a "$LOGFILE"
}

log_success() {
    echo -e "[${GREEN}✓${NC}] $*" | tee -a "$LOGFILE"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $*" | tee -a "$LOGFILE"
}

log_error() {
    echo -e "${RED}✗${NC} $*" | tee -a "$LOGFILE"
}

#######################################
# Progress Bar
#######################################

progressbar() {
    local current=$1
    local total=$2
    
    if [[ "$TERM" == "dumb" ]]; then
        return
    fi
    
    local progress=$(( (current * 100) / total ))
    local done=$(( (progress * 40) / 100 ))
    local left=$(( 40 - done ))
    
    local fill=$(printf "%${done}s" | tr ' ' '#')
    local empty=$(printf "%${left}s" | tr ' ' '-')
    
    printf "\rProgress: [%s%s] %3d%% (%d/%d)" "$fill" "$empty" "$progress" "$current" "$total"
}

#######################################
# Cleanup and Exit Handler
#######################################

cleanup() {
    local exit_code=$?
    
    # Remove lock file
    if [[ -d "$LOCKFILE" ]]; then
        rmdir "$LOCKFILE" 2>/dev/null || true
    fi
    
    # Clean up temporary file
    if [[ -n "$TEMP_OUTPUT" ]] && [[ -f "$TEMP_OUTPUT" ]]; then
        rm -f "$TEMP_OUTPUT"
    fi
    
    # Only show error if we actually started processing (not just showing usage)
    if [[ $exit_code -ne 0 ]] && [[ -n "$TEMP_OUTPUT" ]]; then
        echo ""
        log_error "Script failed with exit code $exit_code"
        
        # Auto-rollback if enabled and we have a working config
        if [[ "$AUTO_ROLLBACK" == "true" ]] && [[ -n "$LAST_WORKING_CONFIG" ]] && [[ -f "$LAST_WORKING_CONFIG" ]]; then
            log_warning "Attempting automatic rollback..."
            if "$NFT_BIN" -f "$LAST_WORKING_CONFIG" 2>/dev/null; then
                log_success "Rollback successful - previous configuration restored"
            else
                log_error "Rollback failed - manual intervention required!"
            fi
        fi
    fi
    
    exit $exit_code
}

trap cleanup EXIT INT TERM

#######################################
# Lock Management
#######################################

acquire_lock() {
    if ! mkdir "$LOCKFILE" 2>/dev/null; then
        log_error "Another instance of $SCRIPT_NAME is already running"
        log_error "Lock file: $LOCKFILE"
        log_error "If no other instance is running, remove the lock file manually"
        exit 1
    fi
}

#######################################
# Dependency Check
#######################################

check_dependencies() {
    local missing_deps=()
    
    for cmd in dig nft systemctl; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_deps+=("$cmd")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        log_error "Please install: apt-get install bind9-dnsutils nftables systemd"
        exit 1
    fi
    
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_warning "Not running as root - some operations may fail"
    fi
}

#######################################
# IP Address Validation
#######################################

validate_ipv4() {
    local ip="$1"
    
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        # Check each octet
        local IFS='.'
        local -a octets=($ip)
        for octet in "${octets[@]}"; do
            if [[ $octet -gt 255 ]]; then
                return 1
            fi
        done
        return 0
    fi
    return 1
}

validate_ipv6() {
    local ip="$1"
    
    # Simplified IPv6 validation
    if [[ $ip =~ ^[0-9a-fA-F:]+$ ]]; then
        # Basic check - at least contains valid characters
        return 0
    fi
    return 1
}

validate_ips() {
    local ips="$1"
    local record_type="$2"
    
    while IFS= read -r ip; do
        [[ -z "$ip" ]] && continue
        
        if [[ "$record_type" == "A" ]]; then
            validate_ipv4 "$ip" || return 1
        elif [[ "$record_type" == "AAAA" ]]; then
            validate_ipv6 "$ip" || return 1
        fi
    done <<< "$ips"
    
    return 0
}

#######################################
# DNS Resolution with Retry
#######################################

resolve_dns() {
    local hostname="$1"
    local record_type="$2"
    local attempt=0
    local result=""
    
    while [[ $attempt -lt $DIG_RETRIES ]]; do
        # Perform DNS lookup with timeout
        result=$(dig +short +time=$DIG_TIMEOUT +tries=1 "$hostname" "$record_type" 2>/dev/null | grep -v '\.$' || true)
        
        if [[ -n "$result" ]]; then
            # Validate IP addresses
            if validate_ips "$result" "$record_type"; then
                echo "$result"
                return 0
            else
                log_warning "Invalid IP addresses returned for $hostname ($record_type) on attempt $((attempt + 1))"
            fi
        fi
        
        ((++attempt))
        
        if [[ $attempt -lt $DIG_RETRIES ]]; then
            sleep 0.5
        fi
    done
    
    return 1
}

#######################################
# Create Backup
#######################################

create_backup() {
    local output_file="$1"
    
    mkdir -p "$BACKUP_DIR"
    
    if [[ -f "$output_file" ]]; then
        local backup_file="$BACKUP_DIR/nftables.conf.$(date +%Y%m%d_%H%M%S)"
        cp "$output_file" "$backup_file"
        log_info "Backup created: $backup_file"
        
        # Keep only last 10 backups
        ls -t "$BACKUP_DIR"/nftables.conf.* 2>/dev/null | tail -n +11 | xargs -r rm
        
        # Update last working config reference
        LAST_WORKING_CONFIG="$BACKUP_DIR/nftables.conf.last_working"
        cp "$output_file" "$LAST_WORKING_CONFIG"
    fi
}

#######################################
# Process Configuration File
#######################################

process_config() {
    local input_file="$1"
    local output_file="$2"
    
    log_info "Processing configuration file: $input_file"
    
    local line_count=$(wc -l < "$input_file")
    local current_line=0
    
    TEMP_OUTPUT="${output_file}.tmp.$$"
    > "$TEMP_OUTPUT"
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        ((++current_line))
        
        if [[ "$line" == *"#DATA"* ]]; then
            # Extract hostname and IP version using regex
            if [[ "$line" =~ define[[:space:]]+([a-zA-Z0-9._-]+)_([46])[[:space:]]*= ]]; then
                local hostname="${BASH_REMATCH[1]}"
                local ip_version="${BASH_REMATCH[2]}"
                local record_type="A"
                
                [[ "$ip_version" -eq 6 ]] && record_type="AAAA"
                
                ((++TOTAL_DOMAINS))
                
                # Resolve DNS with retry
                if ip_addresses=$(resolve_dns "$hostname" "$record_type"); then
                    if [[ -n "$ip_addresses" ]]; then
                        # Convert newlines to commas
                        local ip_list=$(echo "$ip_addresses" | tr '\n' ',' | sed 's/,$//')
                        
                        # Replace #DATA with IP list
                        echo "$line" | sed "s/#DATA/$ip_list/g" >> "$TEMP_OUTPUT"
                        
                        ((++RESOLVED_COUNT))
                        
                        # Rate limiting - small delay between queries
                        sleep "$DNS_DELAY"
                    else
                        log_warning "Empty result for $hostname ($record_type)"
                        FAILED_DOMAINS+=("$hostname ($record_type) - empty result")
                        echo "$line" >> "$TEMP_OUTPUT"
                    fi
                else
                    log_warning "Failed to resolve $hostname ($record_type)"
                    FAILED_DOMAINS+=("$hostname ($record_type) - timeout/DNS error")
                    echo "$line" >> "$TEMP_OUTPUT"
                fi
            else
                # Couldn't parse, keep line as-is
                echo "$line" >> "$TEMP_OUTPUT"
            fi
        else
            # Not a DNS line, keep as-is
            echo "$line" >> "$TEMP_OUTPUT"
        fi
        
        progressbar "$current_line" "$line_count"
    done < "$input_file"
    
    progressbar "$line_count" "$line_count"
    echo ""
}

#######################################
# Validate Syntax
#######################################

validate_syntax() {
    local config_file="$1"
    
    log_info "Validating nftables syntax..."
    
    if "$NFT_BIN" -c -f "$config_file" 2>&1 | tee -a "$LOGFILE"; then
        log_success "Syntax validation passed"
        return 0
    else
        log_error "Syntax validation failed!"
        return 1
    fi
}

#######################################
# Load Configuration (Atomic)
#######################################

load_config() {
    local config_file="$1"
    
    log_info "Loading nftables configuration (atomic reload)..."
    
    # Atomic reload - no need to stop nftables first
    # The 'flush ruleset' in the config will clear old rules
    if "$NFT_BIN" -f "$config_file" 2>&1 | tee -a "$LOGFILE"; then
        log_success "Configuration loaded successfully"
        
        # Update last working config
        if [[ -n "$LAST_WORKING_CONFIG" ]]; then
            cp "$config_file" "$LAST_WORKING_CONFIG"
        fi
        
        return 0
    else
        log_error "Failed to load configuration!"
        return 1
    fi
}

#######################################
# Load Emerging Threats Blocklists
#######################################

load_emerging_threats() {
    log_info "Loading Emerging Threats blocklists..."
    
    local failed=false
    
    # ET-Dshield
    log_info "Fetching ET-Dshield blocklist..."
    if et_dshield=$(timeout 30 curl -sf https://rules.emergingthreats.net/open/suricata-5.0.0/emerging.rules.tar.gz \
        | tar -xzO rules/dshield.rules \
        | grep "alert ip" \
        | cut -d "[" -f 2 \
        | cut -d "]" -f 1 \
        | tr '\n' ',' \
        | sed 's/,$//'); then
        
        # Create set and add elements
        "$NFT_BIN" add set ip filter ET-Dshield "{ type ipv4_addr; flags interval; auto-merge; comment \"Emerging Threats Dshield\"; }" 2>/dev/null || true
        
        if [[ -n "$et_dshield" ]]; then
            "$NFT_BIN" add element ip filter ET-Dshield "{ $et_dshield }" 2>&1 | tee -a "$LOGFILE"
            "$NFT_BIN" add rule ip filter input ip saddr @ET-Dshield drop 2>/dev/null || true
            log_success "ET-Dshield loaded ($(echo "$et_dshield" | tr ',' '\n' | wc -l) IPs)"
        else
            log_warning "ET-Dshield returned empty result"
            failed=true
        fi
    else
        log_error "Failed to fetch ET-Dshield"
        failed=true
    fi
    
    # ET-Spamhaus
    log_info "Fetching ET-Spamhaus blocklist..."
    if et_spamhaus=$(timeout 30 curl -sf https://rules.emergingthreats.net/open/suricata-5.0.0/emerging.rules.tar.gz \
        | tar -xzO rules/drop.rules \
        | grep "alert ip" \
        | cut -d "[" -f 2 \
        | cut -d "]" -f 1 \
        | tr '\n' ',' \
        | sed 's/,$//'); then
        
        # Create set and add elements
        "$NFT_BIN" add set ip filter ET-Spamhaus "{ type ipv4_addr; flags interval; auto-merge; comment \"Emerging Threats Spamhaus\"; }" 2>/dev/null || true
        
        if [[ -n "$et_spamhaus" ]]; then
            "$NFT_BIN" add element ip filter ET-Spamhaus "{ $et_spamhaus }" 2>&1 | tee -a "$LOGFILE"
            "$NFT_BIN" add rule ip filter input ip saddr @ET-Spamhaus drop 2>/dev/null || true
            log_success "ET-Spamhaus loaded ($(echo "$et_spamhaus" | tr ',' '\n' | wc -l) IPs)"
        else
            log_warning "ET-Spamhaus returned empty result"
            failed=true
        fi
    else
        log_error "Failed to fetch ET-Spamhaus"
        failed=true
    fi
    
    if [[ "$failed" == "true" ]]; then
        log_warning "Emerging Threats integration completed with errors (non-critical)"
        return 1
    else
        log_success "Emerging Threats integration completed successfully"
        return 0
    fi
}

#######################################
# Print Summary
#######################################

print_summary() {
    echo ""
    echo "════════════════════════════════════════════════════════"
    echo "                    BUILD SUMMARY"
    echo "════════════════════════════════════════════════════════"
    echo ""
    echo "Total domains found:     $TOTAL_DOMAINS"
    echo "Successfully resolved:   $RESOLVED_COUNT"
    echo "Failed resolutions:      ${#FAILED_DOMAINS[@]}"
    echo ""
    
    if [[ ${#FAILED_DOMAINS[@]} -gt 0 ]]; then
        log_warning "The following domains failed to resolve:"
        for i in "${!FAILED_DOMAINS[@]}"; do
            echo "  $((i + 1)). ${FAILED_DOMAINS[$i]}"
        done
        echo ""
        log_warning "Configuration may be incomplete!"
    else
        log_success "All domains resolved successfully"
    fi
    
    echo "════════════════════════════════════════════════════════"
}

#######################################
# Usage Information
#######################################

usage() {
    cat <<EOF
Usage: $SCRIPT_NAME <input_file> <output_file>

NFTables Configuration Builder v$VERSION

This script resolves domain names in nftables configuration files and builds
a production-ready configuration with IP addresses.

Options:
  <input_file>   Input nftables configuration with #DATA placeholders
  <output_file>  Output file for resolved configuration

Input File Format:
  define domain.tld_4 = {#DATA}    # IPv4 domains
  define domain.tld_6 = {#DATA}    # IPv6 domains

Features:
  • DNS resolution with timeout and retry logic
  • Automatic backup before changes
  • Syntax validation before loading
  • Atomic firewall reload (no downtime)
  • Emerging Threats blocklist integration
  • Comprehensive logging

Examples:
  $SCRIPT_NAME /etc/nftables/config.nft /etc/nftables.conf
  $SCRIPT_NAME nftables_template.conf /etc/nftables.conf

Log File: $LOGFILE
Backups:  $BACKUP_DIR

EOF
}

#######################################
# Main Function
#######################################

main() {
    local input_file="${1:-}"
    local output_file="${2:-}"
    
    # Print header
    echo "════════════════════════════════════════════════════════"
    echo "  NFTables Configuration Builder v$VERSION"
    echo "════════════════════════════════════════════════════════"
    echo ""
    
    # Validate arguments
    if [[ -z "$input_file" ]] || [[ -z "$output_file" ]]; then
        usage
        exit 1
    fi
    
    if [[ ! -f "$input_file" ]]; then
        log_error "Input file not found: $input_file"
        exit 1
    fi
    
    # Initialize
    log_info "Starting build process..."
    check_dependencies
    acquire_lock
    
    # Create backup
    create_backup "$output_file"
    
    # Process configuration
    process_config "$input_file" "$output_file"
    
    # Print summary
    print_summary
    
    # Check if we should proceed despite failures
    if [[ ${#FAILED_DOMAINS[@]} -gt 0 ]]; then
        log_warning "Some domains failed to resolve"
        echo ""
        read -p "Continue with incomplete configuration? [y/N] " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Build aborted by user"
            rm -f "$TEMP_OUTPUT"
            exit 1
        fi
    fi
    
    # Validate syntax
    if ! validate_syntax "$TEMP_OUTPUT"; then
        log_error "Syntax validation failed - aborting"
        exit 1
    fi
    
    # Move temp file to final location
    mv "$TEMP_OUTPUT" "$output_file"
    log_success "Configuration written to: $output_file"
    
    # Load configuration
    if ! load_config "$output_file"; then
        log_error "Failed to load configuration"
        exit 1
    fi
    
    # Load Emerging Threats (optional, non-critical)
    if [[ "$LOAD_EMERGING_THREATS" == "true" ]]; then
        load_emerging_threats || log_warning "Emerging Threats loading failed (non-critical)"
    fi
    
    # Success!
    echo ""
    log_success "Build process completed successfully!"
    log_info "Configuration is now active"
    
    # Optional: restart fail2ban
    # if command -v fail2ban-client &>/dev/null; then
    #     log_info "Restarting fail2ban..."
    #     systemctl restart fail2ban
    # fi
}

#######################################
# Script Entry Point
#######################################

main "$@"
exit 0

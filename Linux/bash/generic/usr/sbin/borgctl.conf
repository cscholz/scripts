#!/bin/bash
# Version=20251013.11
# Wrapper for easy borg usage.

#====================[ exit codes ]====================
# Standardized exit codes for error handling
# 0   = SUCCESS - Operation completed successfully
# 1   = GENERAL_ERROR - Generic/unspecified error
# 2   = CONFIG_ERROR - Configuration missing, invalid, or permissions wrong
# 3   = SSH_ERROR - SSH connection or remote host issues
# 4   = BORG_ERROR - Borg operation failed (non-lock related)
# 5   = LOCK_ERROR - Repository or script lock conflict
# 6   = RESOURCE_ERROR - Disk space, memory, or other resource issues
# 10  = USER_ABORT - User cancelled operation
readonly EXIT_SUCCESS=0
readonly EXIT_GENERAL_ERROR=1
readonly EXIT_CONFIG_ERROR=2
readonly EXIT_SSH_ERROR=3
readonly EXIT_BORG_ERROR=4
readonly EXIT_LOCK_ERROR=5
readonly EXIT_RESOURCE_ERROR=6
readonly EXIT_USER_ABORT=10

#====================[ formatting / colors ]====================
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'
BOLD='\033[1m'
NOBOLD='\033[0m'
CHECKMARK="✓"
CROSSMARK="✗"

# Disable colors if not a TTY or NO_COLOR is set
if [[ ! -t 1 || -n "${NO_COLOR:-}" ]]; then
  GREEN=""; RED=""; YELLOW=""; NC=""; BOLD=""; NOBOLD=""; BLUE=""
fi

#====================[ script + config ]====================
SCRIPT_NAME="$(basename "$0")"
CONFIG_NAME="${SCRIPT_NAME%.sh}.conf"
GLOBAL_CONFIG="/etc/${CONFIG_NAME}"
USER_CONFIG="$HOME/.config/${CONFIG_NAME}"

variables_initialized=false
debug=0

#====================[ logging / debug ]====================
# Log status message with optional newline
# Args: $1=message, $2=newline(0=no,1=yes)
log_status() {
    local msg="$1"
    local newline="${2:-0}"
    if [[ "$newline" == "1" ]]; then
        echo -e "\r${msg}"
    else
        echo -ne "\r${msg}"
    fi
}

# Print debug message if debug mode is enabled
# Args: $@=command/message to display
debug_msg() {
    if [[ "$debug" == "1" ]]; then
        log_status "  ${YELLOW}\$ $*${NC}" 1
    fi
}

#====================[ runtime prerequisites ]====================
# Check if a package is installed and offer to install it
# Args: $1=executable name, $2=package name
checkpackage() {
  local exec="$1"
  local pkg="$2"
  if ! command -v "$exec" >/dev/null 2>&1; then
    echo -e "${RED}Package \"$pkg\" not found!${NC}"
    read -p "Install? (y/N) " -r
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      sudo apt-get update
      sudo apt-get install -y "$pkg"
    else
      exit "$EXIT_GENERAL_ERROR"
    fi
  fi
}

checkpackage borg borgbackup
checkpackage mail mailutils
checkpackage curl curl

#====================[ tempfiles + traps ]====================
__TMPFILES=()
__BACKUP_SUCCESS=0  # Track if backup was successful for post-hook

# Register a temporary file for cleanup
# Args: $1=filepath
register_tmpfile() { 
    __TMPFILES+=("$1")
}

# Cleanup temporary files and run post-backup hook if applicable
cleanup_on_exit() {
  # Run post-backup hook only if backup was successful
  if [[ "${__BACKUP_SUCCESS}" == "1" && -n "${post_backup_cmd:-}" ]]; then
    log_status "[ ] Running post-backup hook" 1
    debug_msg "${post_backup_cmd}"
    if bash -c "${post_backup_cmd}"; then
        log_status "[${GREEN}${CHECKMARK}${NC}] Post-backup hook completed" 1
    else
        log_status "[${YELLOW}!${NC}] Post-backup hook exited non-zero" 1
    fi
  fi
  
  # Clean up all temporary files
  for f in "${__TMPFILES[@]}"; do
    [[ -n "$f" ]] && rm -f "$f" 2>/dev/null || true
  done
}
trap cleanup_on_exit EXIT

#====================[ config permission check ]====================
# Verify config file has secure permissions (0600)
# Args: $1=config file path
check_config_permissions() {
    local cfg="$1"
    if [[ -f "$cfg" ]]; then
        local mode
        mode=$(stat -c "%a" "$cfg")
        if [[ "$mode" != "600" ]]; then
            log_status "[${RED}${CROSSMARK}${NC}] Config file $cfg must have permissions 0600, but has $mode" 1
            exit "$EXIT_CONFIG_ERROR"
        fi
    fi
}

check_config_permissions "$GLOBAL_CONFIG"
check_config_permissions "$USER_CONFIG"

#====================[ args ]====================
args=()
for arg in "$@"; do
    if [[ "$arg" == "-v" ]]; then
        debug=1
    else
        args+=("$arg")
    fi
done
set -- "${args[@]}"

#====================[ config loading ]====================
config_loaded=0
if [[ -f "$GLOBAL_CONFIG" ]]; then
    # shellcheck source=/dev/null
    source "$GLOBAL_CONFIG"
    config_loaded=1
fi
if [[ -f "$USER_CONFIG" ]]; then
    # shellcheck source=/dev/null
    source "$USER_CONFIG"
    config_loaded=1
fi

if [[ "$config_loaded" -eq 0 ]]; then
    log_status "[${RED}${CROSSMARK}${NC}] No configuration file found!" 1
    exit "$EXIT_CONFIG_ERROR"
fi

# Export borg environment variable if set in config
if [[ "${BORG_RELOCATED_REPO_ACCESS_IS_OK:-no}" == "yes" ]]; then
    export BORG_RELOCATED_REPO_ACCESS_IS_OK=yes
fi

# Validate required configuration variables
if [[ -z "${ssh_remote_host:-}" || -z "${ssh_remote_user:-}" || -z "${ssh_remote_folder:-}" || -z "${borg_backup_name_format:-}" ]]; then
    log_status "[${RED}${CROSSMARK}${NC}] No valid configuration found!" 1
    exit "$EXIT_CONFIG_ERROR"
fi

# Validate compression setting (default to lz4 if not set or invalid)
if [[ -z "${compression:-}" ]]; then
    compression="lz4"
    debug_msg "Compression not set, defaulting to: ${compression}"
fi

#====================[ run lock (acquire on demand) ]====================
LOCK_DIR="/var/lock"; [[ -w "$LOCK_DIR" ]] || LOCK_DIR="/tmp"
LOCK_FILE="${LOCK_DIR}/${SCRIPT_NAME}.lock"
__LOCKED=0

# Acquire exclusive script lock to prevent concurrent runs
acquire_run_lock() {
  if [[ "$__LOCKED" -eq 1 ]]; then return 0; fi
  exec 9>"$LOCK_FILE"
  if ! flock -n 9; then
    log_status "[${RED}${CROSSMARK}${NC}] Another run is in progress (lock: $LOCK_FILE)" 1
    exit "$EXIT_LOCK_ERROR"
  fi
  __LOCKED=1
}

#====================[ helpers ]====================
# Execute command with debug output
# Args: $@=command to execute
run_cmd() {
    local cmd="$*"
    debug_msg "$cmd"
    eval "$cmd"
    return $?
}

# Create a secure temporary file and register it for cleanup
tempfile() {
    umask 077
    local t
    t=$(mktemp "/tmp/$(basename "$0").XXXXXX")
    register_tmpfile "$t"
    printf "%s" "$t"
}

# Initialize borg environment variables
# Args: $1=job_name (optional, default: "full")
set_variables() {
    local job_name="${1:-full}"
    
    if [[ "$variables_initialized" == false ]]; then
        export BORG_PASSPHRASE="${borg_passphrase}"
        export BORG_RSH="ssh -p ${ssh_remote_port} -oStrictHostKeyChecking=no -oBatchMode=yes -i ${ssh_remote_authfile}"
        
        # Validate SSH key file exists
        if [[ ! -f "${ssh_remote_authfile}" ]]; then
            log_status "[${RED}${CROSSMARK}${NC}] SSH key file not found: ${ssh_remote_authfile}" 1
            exit "$EXIT_CONFIG_ERROR"
        fi
        
        temp=$(tempfile)
        variables_initialized=true
        log_status "[${GREEN}${CHECKMARK}${NC}] Setting variables" 1
        debug_msg "BORG_RSH=${BORG_RSH}"
        debug_msg "temp=${temp}"
    fi
    
    # Generate snapshot name based on format
    if [[ "$borg_backup_name_format" == *'%'* ]]; then
        snapshot_name=$(date +"$borg_backup_name_format")
    else
        snapshot_name=$(eval echo "$borg_backup_name_format")
    fi
    
    # Add prefix if configured
    if [[ -n "${default_backup_prefix:-}" ]]; then
        snapshot_name="${snapshot_name}_${default_backup_prefix}"
    fi
    
    debug_msg "snapshot_name=${snapshot_name}"
    debug_msg "repo_name=${repo_name:-}"
}

# Build repository path
repo_name=$(eval echo "${borg_repo_name_format:-}")
if [[ -n "$repo_name" ]]; then
    repo_path="${ssh_remote_user}@${ssh_remote_host}:${ssh_remote_folder}${repo_name}"
else
    repo_path="${ssh_remote_user}@${ssh_remote_host}:${ssh_remote_folder}"
fi

# Test SSH connectivity to remote host
# Returns: EXIT_SUCCESS on success, EXIT_SSH_ERROR on failure
ssh_connection_test() {
    log_status "[ ] Testing SSH connection to ${ssh_remote_host}"
    
    local timeout_val="${borg_operation_timeout:-300}"
    local ssh_output
    local rc
    
    # Test SSH connection using 'borg serve --info' which is a valid borg command
    # that will work with restricted shells configured for borg-only access
    ssh_output=$(timeout "$timeout_val" ssh -p "${ssh_remote_port}" \
        -oStrictHostKeyChecking=no \
        -oBatchMode=yes \
        -oConnectTimeout=10 \
        -i "${ssh_remote_authfile}" \
        "${ssh_remote_user}@${ssh_remote_host}" "borg serve --info" 2>&1 <<< "" | head -1)
    rc=$?
    
    # Debug output
    if [[ "$debug" == "1" && -n "$ssh_output" ]]; then
        debug_msg "SSH output: $ssh_output"
        debug_msg "SSH exit code: $rc"
    fi
    
    # borg serve --info will hang waiting for commands, but if we can connect and
    # see borg running, connection is good. We send empty input and check if
    # we got any response or if connection succeeded
    if [[ $rc -eq 0 ]] || [[ "$ssh_output" == *"borg"* ]] || [[ $rc -eq 141 ]]; then
        # rc=141 is SIGPIPE which is expected when we close input to borg serve
        log_status "[${GREEN}${CHECKMARK}${NC}] Testing SSH connection to ${ssh_remote_host}" 1
        return "$EXIT_SUCCESS"
    else
        log_status "[${RED}${CROSSMARK}${NC}] Testing SSH connection to ${ssh_remote_host}" 1
        if [[ "$debug" == "1" ]]; then
            log_status "    ${YELLOW}SSH connection failed with exit code: ${rc}${NC}" 1
            if [[ -n "$ssh_output" ]]; then
                log_status "    ${YELLOW}Error: ${ssh_output}${NC}" 1
            fi
        fi
        return "$EXIT_SSH_ERROR"
    fi
}

# Check if repository is reachable
# Returns: EXIT_SUCCESS on success, EXIT_SSH_ERROR or EXIT_BORG_ERROR on failure
repo_preflight() {
  log_status "[ ] Repository reachability check"
  
  local timeout_val="${borg_operation_timeout:-300}"
  
  if timeout "$timeout_val" borg info "$repo_path" >/dev/null 2>&1; then
    log_status "[${GREEN}${CHECKMARK}${NC}] Repository reachability check" 1
    return "$EXIT_SUCCESS"
  else
    log_status "[${RED}${CROSSMARK}${NC}] Repository reachability check" 1
    return "$EXIT_BORG_ERROR"
  fi
}

# Check available disk space on remote server
# Returns: EXIT_SUCCESS if enough space or check disabled, EXIT_RESOURCE_ERROR if not enough
check_remote_disk_space() {
    # Check if disk space check is enabled (default: yes)
    local check_enabled="${check_remote_disk_space:-yes}"
    
    if [[ "$check_enabled" != "yes" ]]; then
        debug_msg "Remote disk space check disabled in config"
        return "$EXIT_SUCCESS"
    fi
    
    log_status "[ ] Checking remote disk space"
    
    local min_space_mb="${min_remote_space_mb:-1024}"  # Default 1GB
    local remote_path="${ssh_remote_folder}"
    
    # Get available space in MB via SSH
    # This may not work with restricted shells or containerized borg servers
    local available_mb
    available_mb=$(timeout 10 ssh -p "${ssh_remote_port}" \
        -oStrictHostKeyChecking=no \
        -oBatchMode=yes \
        -i "${ssh_remote_authfile}" \
        "${ssh_remote_user}@${ssh_remote_host}" \
        "df -BM '${remote_path}' | tail -1 | awk '{print \$4}' | sed 's/M//'" 2>/dev/null)
    
    if [[ -z "$available_mb" || ! "$available_mb" =~ ^[0-9]+$ ]]; then
        log_status "[${YELLOW}!${NC}] Could not determine remote disk space (set check_remote_disk_space=no to disable)" 1
        # Don't fail the backup if we can't check, just warn
        return "$EXIT_SUCCESS"
    fi
    
    debug_msg "Available space: ${available_mb}MB, Required: ${min_space_mb}MB"
    
    if [[ "$available_mb" -lt "$min_space_mb" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] Insufficient disk space (${available_mb}MB < ${min_space_mb}MB)" 1
        return "$EXIT_RESOURCE_ERROR"
    fi
    
    log_status "[${GREEN}${CHECKMARK}${NC}] Checking remote disk space (${available_mb}MB available)" 1
    return "$EXIT_SUCCESS"
}

# Send email notification
# Args: $1=subject, $2=body_file
send_mail_notification() {
    local subject="$1"
    local body_file="$2"
    
    if [[ -n "${mail_recipient:-}" ]]; then
        debug_msg "mail -s \"$subject\" \"${mail_recipient}\" < \"$body_file\""
        mail -s "$subject" "${mail_recipient}" < "$body_file"
        return $?
    fi
    return "$EXIT_SUCCESS"
}

# Send heartbeat to monitoring URL
# Args: $1=status (success/failure)
send_heartbeat() {
    local status="$1"
    local url=""
    
    if [[ "$status" == "success" && -n "${heartbeat_success_url:-}" ]]; then
        url="${heartbeat_success_url}"
    elif [[ "$status" == "failure" && -n "${heartbeat_failure_url:-}" ]]; then
        url="${heartbeat_failure_url}"
    else
        return "$EXIT_SUCCESS"
    fi
    
    log_status "[ ] Sending heartbeat (${status})"
    if curl -sS --max-time 10 "$url" >/dev/null 2>&1; then
        log_status "[${GREEN}${CHECKMARK}${NC}] Sending heartbeat (${status})" 1
        return "$EXIT_SUCCESS"
    else
        # Don't fail the backup if heartbeat fails
        log_status "[${YELLOW}!${NC}] Sending heartbeat failed (${status}) - continuing" 1
        return "$EXIT_SUCCESS"
    fi
}

# Handle borg backup warnings (exit code 1)
# Args: $1=borg_output, $2=snapshot_name
handle_backup_warnings() {
    local borg_output="$1"
    local snapshot_name="$2"
    
    log_status "[${YELLOW}!${NC}] Backup completed with warnings" 1
    log_status "    ${YELLOW}Some files may have changed during backup${NC}" 1
    log_status "    ${YELLOW}Review the email report for details${NC}" 1
    
    if [[ -n "${mail_recipient:-}" ]]; then
        local subject="$(hostname) backup (warnings) - [${snapshot_name}]"
        local mailfile
        mailfile=$(tempfile)
        {
            echo "Backup completed with WARNINGS"
            echo "================================"
            echo
            borg info "${repo_path}::${snapshot_name}" 2>&1 || echo "Could not retrieve archive info"
            echo
            echo "Warnings and changed files:"
            echo "----------------------------"
            printf "%s\n" "$borg_output" | grep -E "file changed while we backed it up|Warning|changed while" || echo "(no specific warning lines captured)"
        } > "$mailfile"
        send_mail_notification "$subject" "$mailfile"
    fi
    
    send_heartbeat "success"
    return "$EXIT_SUCCESS"
}

# Show progress bar for long operations
# Args: $1=operation_name, $2=command_to_run
show_progress() {
    local operation="$1"
    shift
    local cmd="$*"
    
    log_status "[ ] ${operation}" 1
    
    # If debug mode, show full output
    if [[ "$debug" == "1" ]]; then
        eval "$cmd"
        return $?
    fi
    
    # Otherwise show spinner
    local spin='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local i=0
    
    eval "$cmd" &
    local pid=$!
    
    while kill -0 "$pid" 2>/dev/null; do
        i=$(( (i+1) % 10 ))
        log_status "[ ${spin:$i:1} ] ${operation}"
        sleep 0.1
    done
    
    wait "$pid"
    local rc=$?
    
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] ${operation}" 1
    else
        log_status "[${RED}${CROSSMARK}${NC}] ${operation}" 1
    fi
    
    return $rc
}

#====================[ backup functions ]====================
# Create a new backup archive
# Args: $1=include_path (optional), $2=backup_suffix (optional)
backup_create() {
    acquire_run_lock
    local include_path="${1:-}"
    local backup_suffix="${2:-}"
    set_variables "full"

    # Test SSH connection first
    if ! ssh_connection_test; then
        return "$EXIT_SSH_ERROR"
    fi

    # Run pre-backup hook if configured
    if [[ -n "${pre_backup_cmd:-}" ]]; then
      log_status "[ ] Running pre-backup hook" 1
      debug_msg "${pre_backup_cmd}"
      if ! bash -c "${pre_backup_cmd}"; then
        log_status "[${RED}${CROSSMARK}${NC}] Pre-backup hook failed" 1
        return "$EXIT_BORG_ERROR"
      fi
      log_status "[${GREEN}${CHECKMARK}${NC}] Pre-backup hook completed" 1
    fi

    # Check repository accessibility
    repo_preflight || return "$EXIT_BORG_ERROR"
    
    # Check remote disk space
    check_remote_disk_space || return "$EXIT_RESOURCE_ERROR"

    # Prepare backup paths
    local -a include_paths=("${backup_paths[@]}")
    [[ -n "$include_path" ]] && include_paths=("$include_path")
    [[ ${#include_paths[@]} -eq 0 ]] && include_paths=("/")

    # Generate snapshot name with suffix if provided
    if [[ -n "$backup_suffix" ]]; then
        if [[ "$borg_backup_name_format" == *'%'* ]]; then
            snapshot_name="$(date +"$borg_backup_name_format")"
        else
            snapshot_name=$(eval echo "$borg_backup_name_format")
        fi
        snapshot_name="${snapshot_name}_${backup_suffix}"
    fi

    log_status "[ ] Creating backup: ${snapshot_name}" 1
    echo

    # Prepare borg create options
    local borg_create_opts=(
        --exclude-caches 
        --exclude-nodump 
        --compression "${compression}"
        "${exclude_args[@]}"
    )
    
    local timeout_val="${borg_operation_timeout:-3600}"
    
    # Create temporary file to capture output for email
    local borg_log_file
    borg_log_file=$(tempfile)
    
    # Execute backup with timeout, showing progress on console and saving to log
    timeout "$timeout_val" borg create \
        "${borg_create_opts[@]}" \
        --stats \
        --progress \
        "${repo_path}::${snapshot_name}" \
        "${include_paths[@]}" 2>&1 | tee "$borg_log_file"
    local rc=${PIPESTATUS[0]}

    echo
    
    # Handle timeout
    if [[ $rc -eq 124 ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] Backup timed out after ${timeout_val}s" 1
        send_heartbeat "failure"
        return "$EXIT_BORG_ERROR"
    fi

    # Read log file for email notifications
    local borg_output
    borg_output=$(cat "$borg_log_file")

    # Handle lock errors
    if [[ $rc -ne 0 && "$borg_output" == *"Failed to create/acquire the lock"* ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] Repository locked, backup aborted" 1
        if [[ -n "${mail_recipient:-}" ]]; then
            local subject="$(hostname) backup LOCKED - [${snapshot_name}]"
            local mailfile
            mailfile=$(tempfile)
            {
                echo "Backup aborted due to repository lock."
                echo "Repository: ${repo_path}"
                echo "Backup name: ${snapshot_name}"
                echo
                echo "borg output:"
                echo "$borg_output"
            } > "$mailfile"
            send_mail_notification "$subject" "$mailfile"
        fi
        send_heartbeat "failure"
        return "$EXIT_LOCK_ERROR"

    # Handle success
    elif [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] Creating backup: ${snapshot_name}" 1
        __BACKUP_SUCCESS=1  # Mark for post-hook execution
        
        local report_file
        report_file=$(tempfile)
        borg info "${repo_path}::${snapshot_name}" > "$report_file" 2>&1
        
        if [[ -n "${mail_recipient:-}" ]]; then
            local subject="$(hostname) backup SUCCESS - [${snapshot_name}]"
            send_mail_notification "$subject" "$report_file"
        fi
        
        send_heartbeat "success"

    # Handle warnings (exit code 1)
    elif [[ $rc -eq 1 ]]; then
        __BACKUP_SUCCESS=1  # Still consider successful for post-hook
        handle_backup_warnings "$borg_output" "$snapshot_name"

    # Handle general errors
    else
        log_status "[${RED}${CROSSMARK}${NC}] Creating backup: ${snapshot_name}" 1
        if [[ -n "${mail_recipient:-}" ]]; then
            local subject="$(hostname) backup FAILED - [${snapshot_name}]"
            local mailfile
            mailfile=$(tempfile)
            {
                echo "Backup FAILED."
                echo "Repository: ${repo_path}"
                echo "Backup name: ${snapshot_name}"
                echo "Exit code: ${rc}"
                echo
                echo "borg output:"
                echo "$borg_output"
            } > "$mailfile"
            send_mail_notification "$subject" "$mailfile"
        fi
        send_heartbeat "failure"
        return "$EXIT_BORG_ERROR"
    fi
    
    return "$EXIT_SUCCESS"
}

# Delete one or more backup archives
# Args: $@=archive_names
backup_delete() {
    acquire_run_lock
    set_variables "full"
    
    if [[ "$#" -eq 0 ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] No archive name(s) specified for deletion!" 1
        return "$EXIT_GENERAL_ERROR"
    fi

    for archive_name in "$@"; do
        log_status "[ ] Deleting backup: $archive_name"
        debug_msg "borg delete -v ${repo_path}::${archive_name}"
        
        local mailfile
        mailfile=$(tempfile)
        echo "----- Repository Info BEFORE deletion -----" >> "$mailfile"
        echo "Backup to be deleted: ${archive_name}" >> "$mailfile"
        borg info "$repo_path" >> "$mailfile" 2>&1
        echo >> "$mailfile"
        
        borg delete -v "${repo_path}::${archive_name}" 2>&1
        local rc=$?
        
        if [[ $rc -eq 0 ]]; then
            log_status "[${GREEN}${CHECKMARK}${NC}] Deleting backup: $archive_name" 1
            echo "----- Repository Info AFTER deletion -----" >> "$mailfile"
            borg info "$repo_path" >> "$mailfile" 2>&1
            
            if [[ -n "${mail_recipient:-}" ]]; then
                local subject="$(hostname) backup deleted - [${archive_name}]"
                send_mail_notification "$subject" "$mailfile"
            fi
        else
            log_status "[${RED}${CROSSMARK}${NC}] Deleting backup: $archive_name" 1
            return "$EXIT_BORG_ERROR"
        fi
    done
    
    return "$EXIT_SUCCESS"
}

# List all backups and optionally send via email
backup_list_and_mail() {
    acquire_run_lock  # Lock added: Borg blocks read access during operations
    set_variables "full"
    log_status "[ ] Listing all backups" 1
    
    local mailfile
    mailfile=$(tempfile)
    debug_msg "borg list $repo_path > $mailfile"
    
    borg list "$repo_path" > "$mailfile" 2>&1
    local rc=$?
    
    cat "$mailfile"
    
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] Listing all backups" 1
        if [[ -n "${mail_recipient:-}" ]]; then
            local subject="$(hostname) backup list - [${repo_name}]"
            send_mail_notification "$subject" "$mailfile"
            log_status "[${GREEN}${CHECKMARK}${NC}] E-Mail notification sent to ${mail_recipient}" 1
        fi
    else
        log_status "[${RED}${CROSSMARK}${NC}] Listing all backups" 1
    fi
    
    return "$rc"
}

# Mount a backup archive or repository
# Args: $1=archive (optional), $2=mountpoint (optional)
backup_mount() {
    acquire_run_lock  # Lock added: Borg blocks access during mount operations
    set_variables "full"
    local archive="${1:-}"
    local mountpoint="${2:-${borg_mount_point:-/mnt/borgbackup_mount}}"
    local msg
    
    if [[ -n "$archive" ]]; then
        msg="[ ] Mounting archive: $archive"
    else
        msg="[ ] Mounting repository (read-only)"
    fi
    log_status "$msg"

    # Check if mountpoint is already in use
    if findmnt "$mountpoint" >/dev/null 2>&1; then
        log_status "[${RED}${CROSSMARK}${NC}] Mountpoint $mountpoint is already mounted" 1
        return "$EXIT_GENERAL_ERROR"
    fi
    
    if [[ -n "$(ls -A "$mountpoint" 2>/dev/null)" ]]; then
        log_status "[${YELLOW}!${NC}] Mountpoint $mountpoint is not empty" 1
    fi

    # Create mountpoint if it doesn't exist
    if [[ ! -d "$mountpoint" ]]; then
        debug_msg "mkdir -p \"$mountpoint\""
        mkdir -p "$mountpoint"
    fi
    
    # Mount archive or repository
    if [[ -n "$archive" ]]; then
        debug_msg "borg mount \"${repo_path}::${archive}\" \"$mountpoint\""
        borg mount "${repo_path}::${archive}" "$mountpoint"
    else
        debug_msg "borg mount \"$repo_path\" \"$mountpoint\""
        borg mount "$repo_path" "$mountpoint"
    fi
    
    local rc=$?
    
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] ${msg:4}" 1
        echo "Unmount with: borg umount $mountpoint"
    else
        log_status "[${RED}${CROSSMARK}${NC}] ${msg:4}" 1
        return "$EXIT_BORG_ERROR"
    fi
    
    return "$EXIT_SUCCESS"
}

# Interactive archive selection for mount/delete operations
# Args: $1=operation (mount/delete)
select_archive_interactive() {
    local operation="$1"
    acquire_run_lock  # Lock added: Archive listing requires repository access
    set_variables "full"
    
    log_status "[ ] Fetching archive list..." 1
    
    local archives
    mapfile -t archives < <(borg list --short "$repo_path" 2>/dev/null)
    
    if [[ ${#archives[@]} -eq 0 ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] No archives found in repository" 1
        return "$EXIT_GENERAL_ERROR"
    fi
    
    echo
    echo "Available archives:"
    echo "==================="
    local i=1
    for archive in "${archives[@]}"; do
        printf "%3d) %s\n" "$i" "$archive"
        ((i++))
    done
    echo
    
    read -rp "Select archive number (or 'q' to quit): " selection
    
    if [[ "$selection" == "q" || "$selection" == "Q" ]]; then
        return "$EXIT_USER_ABORT"
    fi
    
    if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ "$selection" -lt 1 ]] || [[ "$selection" -gt ${#archives[@]} ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] Invalid selection" 1
        return "$EXIT_GENERAL_ERROR"
    fi
    
    local selected_archive="${archives[$((selection-1))]}"
    
    case "$operation" in
        mount)
            backup_mount "$selected_archive"
            ;;
        delete)
            echo
            read -rp "Really delete archive '${selected_archive}'? (yes/NO): " confirm
            if [[ "$confirm" == "yes" ]]; then
                backup_delete "$selected_archive"
            else
                log_status "[${YELLOW}!${NC}] Deletion cancelled" 1
                return "$EXIT_USER_ABORT"
            fi
            ;;
    esac
}

# Restore files from a backup archive
# Args: $1=archive, $2=destination, $3=path_to_restore (optional)
backup_restore() {
    acquire_run_lock  # Lock added: Restore requires repository access
    local archive="$1"
    local destination="$2"
    local restore_path="${3:-}"
    
    if [[ -z "$archive" || -z "$destination" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] Usage: backup restore <archive> <destination> [path]" 1
        return "$EXIT_GENERAL_ERROR"
    fi
    
    set_variables "full"
    
    # Create destination if it doesn't exist
    if [[ ! -d "$destination" ]]; then
        debug_msg "mkdir -p \"$destination\""
        mkdir -p "$destination"
    fi
    
    log_status "[ ] Restoring from archive: ${archive}" 1
    
    local borg_cmd="borg extract \"${repo_path}::${archive}\""
    if [[ -n "$restore_path" ]]; then
        borg_cmd="${borg_cmd} \"${restore_path}\""
    fi
    
    debug_msg "cd \"$destination\" && ${borg_cmd}"
    
    (
        cd "$destination" || exit "$EXIT_GENERAL_ERROR"
        eval "$borg_cmd"
    )
    local rc=$?
    
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] Restoring from archive: ${archive}" 1
        echo "Files restored to: $destination"
    else
        log_status "[${RED}${CROSSMARK}${NC}] Restoring from archive: ${archive}" 1
        return "$EXIT_BORG_ERROR"
    fi
    
    return "$EXIT_SUCCESS"
}

#====================[ repo functions ]====================
# Initialize a new borg repository
repo_init() {
    set_variables "full"
    log_status "[ ] Initializing repository"
    debug_msg "borg init -e repokey \"$repo_path\""
    
    borg init -e repokey "$repo_path"
    local rc=$?
    
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] Initializing repository" 1
    else
        log_status "[${RED}${CROSSMARK}${NC}] Initializing repository" 1
        return "$EXIT_BORG_ERROR"
    fi
    
    return "$EXIT_SUCCESS"
}

# Display repository information
repo_info() {
    acquire_run_lock  # Lock added: Repository info requires repository access
    set_variables "full"
    log_status "[ ] Retrieving repository info" 1
    
    borg info "$repo_path"
    local rc=$?
    
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] Retrieving repository info" 1
    else
        log_status "[${RED}${CROSSMARK}${NC}] Retrieving repository info" 1
        return "$EXIT_BORG_ERROR"
    fi
    
    return "$EXIT_SUCCESS"
}

# Check repository integrity
repo_health_check() {
    acquire_run_lock  # Lock added: Health check requires repository access
    set_variables "full"
    log_status "[ ] Checking repository health"
    debug_msg "borg check \"$repo_path\""
    
    borg check "$repo_path"
    local rc=$?
    
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] Checking repository health" 1
    else
        log_status "[${RED}${CROSSMARK}${NC}] Checking repository health" 1
        return "$EXIT_BORG_ERROR"
    fi
    
    return "$EXIT_SUCCESS"
}

# Perform repository maintenance (prune + compact)
repo_maintain() {
    acquire_run_lock
    set_variables "full"
    
    # Prune old backups
    log_status "[ ] Pruning old backups" 1
    run_cmd borg prune "$repo_path" -v --list \
        --keep-within="${borg_keep_within:-6m}" \
        --keep-daily="${borg_keep_daily:-7}" \
        --keep-weekly="${borg_keep_weekly:-12}" \
        --keep-monthly="${borg_keep_monthly:-12}" \
        --keep-yearly="${borg_keep_yearly:-3}"
    local rc=$?
    
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] Pruning old backups" 1
    else
        log_status "[${RED}${CROSSMARK}${NC}] Pruning old backups" 1
        return "$EXIT_BORG_ERROR"
    fi

    # Compact repository
    log_status "[ ] Compacting repository" 1
    local threshold="${borg_compact_threshold:-10}"
    debug_msg "Using compaction threshold: ${threshold}%"
    run_cmd borg compact "$repo_path" -v --threshold "$threshold" --progress
    rc=$?
    
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] Compacting repository" 1
    else
        log_status "[${RED}${CROSSMARK}${NC}] Compacting repository" 1
        return "$EXIT_BORG_ERROR"
    fi
    
    return "$EXIT_SUCCESS"
}

# Check if repository has an active lock
repo_lock_check() {
    set_variables "full"
    log_status "[ ] Checking for repository lock"
    debug_msg "borg info \"$repo_path\""
    
    local repostatus
    repostatus=$(borg info "$repo_path" 2>&1)
    local rc=$?
    
    # Check for lock error message
    if [[ "${repostatus}" == *"Failed to create/acquire the lock"* ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] Repository is locked" 1
        return "$EXIT_LOCK_ERROR"
    fi
    
    # Check if command succeeded
    if [[ $rc -ne 0 ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] Repository check failed" 1
        return "$EXIT_BORG_ERROR"
    fi
    
    log_status "[${GREEN}${CHECKMARK}${NC}] No repository lock detected" 1
    return "$EXIT_SUCCESS"
}

# Break repository lock (use with caution!)
repo_lock_break() {
    set_variables "full"
    log_status "[ ] Breaking repository lock"
    
    echo
    echo "${YELLOW}WARNING: Only break the lock if you're sure no other process is using the repository!${NC}"
    read -rp "Are you sure you want to break the lock? (yes/NO): " confirm
    
    if [[ "$confirm" != "yes" ]]; then
        log_status "[${YELLOW}!${NC}] Lock break cancelled" 1
        return "$EXIT_USER_ABORT"
    fi
    
    debug_msg "borg break-lock \"$repo_path\""
    borg break-lock "$repo_path"
    local rc=$?
    
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] Breaking repository lock" 1
    else
        log_status "[${RED}${CROSSMARK}${NC}] Breaking repository lock" 1
        return "$EXIT_BORG_ERROR"
    fi
    
    return "$EXIT_SUCCESS"
}

#====================[ config management ]====================
# Generate example configuration file
generate_example_config() {
    cat <<'EOF'
# borgctl Configuration File
# ==========================
# Place this file at: /etc/borgctl.conf (system-wide) or ~/.config/borgctl.conf (user)
# File permissions must be 0600 (chmod 600 /path/to/borgctl.conf)

# --- SSH Connection Settings ---
ssh_remote_host="backup.example.com"
ssh_remote_user="backupuser"
ssh_remote_port="22"
ssh_remote_authfile="/home/user/.ssh/id_rsa"
ssh_remote_folder="/backup/borg/"

# --- Repository Settings ---
borg_repo_name_format="$(hostname)"
borg_passphrase="YourSecurePassphraseHere"

# --- Backup Settings ---
borg_backup_name_format="\$(date +%Y-%m-%d_%H%M%S)"
default_backup_prefix="auto"
compression="auto,zstd"  # Options: lz4, zstd, zlib, lzma, auto,zstd

# --- Backup Paths ---
backup_paths=(
    "/home"
    "/etc"
    "/var/www"
)

# --- Exclude Patterns ---
exclude_args=(
    --exclude '/home/*/.cache'
    --exclude '*.tmp'
    --exclude '/var/tmp'
)

# --- Retention Policy ---
borg_keep_within="6m"    # Keep all backups within 6 months
borg_keep_daily="7"      # Keep 7 daily backups
borg_keep_weekly="12"    # Keep 12 weekly backups
borg_keep_monthly="12"   # Keep 12 monthly backups
borg_keep_yearly="3"     # Keep 3 yearly backups

# --- Maintenance Settings ---
borg_compact_threshold="10"  # Compact when 10% space can be freed

# --- Operation Timeouts (in seconds) ---
borg_operation_timeout="3600"  # Timeout for borg operations (1 hour)

# --- Resource Checks ---
check_remote_disk_space="yes"   # Check remote disk space before backup (yes/no)
min_remote_space_mb="1024"      # Minimum required remote disk space in MB

# --- Hooks (optional) ---
# pre_backup_cmd="systemctl stop myapp"
# post_backup_cmd="systemctl start myapp"

# --- Notifications ---
mail_recipient="admin@example.com"

# --- Monitoring (optional) ---
heartbeat_success_url="https://hc-ping.com/your-uuid"
heartbeat_failure_url="https://hc-ping.com/your-uuid/fail"

# --- Mount Point ---
borg_mount_point="/mnt/borgbackup_mount"

# --- Advanced Options ---
# BORG_RELOCATED_REPO_ACCESS_IS_OK="yes"
EOF
}

# Interactive configuration wizard
init_config_wizard() {
    local config_path="$USER_CONFIG"
    
    echo "${BOLD}Borg Backup Configuration Wizard${NOBOLD}"
    echo "===================================="
    echo
    
    if [[ -f "$config_path" ]]; then
        echo "${YELLOW}Config file already exists: $config_path${NC}"
        read -rp "Overwrite? (y/N): " confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            return "$EXIT_USER_ABORT"
        fi
    fi
    
    # Create config directory if needed
    local config_dir
    config_dir=$(dirname "$config_path")
    [[ ! -d "$config_dir" ]] && mkdir -p "$config_dir"
    
    echo
    echo "Creating example configuration at: $config_path"
    
    generate_example_config > "$config_path"
    chmod 600 "$config_path"
    
    echo
    echo "${GREEN}${CHECKMARK}${NC} Configuration file created!"
    echo
    echo "${YELLOW}IMPORTANT: Edit the configuration file and set your values:${NC}"
    echo "  ${BOLD}$config_path${NOBOLD}"
    echo
    echo "Required settings:"
    echo "  - ssh_remote_host, ssh_remote_user, ssh_remote_authfile"
    echo "  - borg_passphrase (keep this secure!)"
    echo "  - backup_paths"
    echo
    
    read -rp "Open config file now in editor? (Y/n): " edit_now
    if [[ ! "$edit_now" =~ ^[Nn]$ ]]; then
        ${EDITOR:-nano} "$config_path"
    fi
    
    return "$EXIT_SUCCESS"
}

# Display README documentation
show_readme() {
    cat <<'EOF'
# borgctl - Borg Backup Wrapper Script

## Overview
borgctl is a comprehensive wrapper script for BorgBackup that simplifies backup operations,
adds monitoring capabilities, and provides additional safety features.

## Features
- ✓ Automated backup creation with compression and deduplication
- ✓ Email notifications for backup status
- ✓ Monitoring integration (heartbeat URLs)
- ✓ Pre/post backup hooks
- ✓ Repository maintenance (prune + compact)
- ✓ SSH connection testing
- ✓ Remote disk space checks
- ✓ Lock management
- ✓ Interactive archive selection
- ✓ Easy restore functionality
- ✓ Comprehensive error handling with standardized exit codes

## Installation
1. Download borgctl.sh to your system
2. Make it executable: `chmod +x borgctl.sh`
3. Create configuration: `./borgctl.sh init-config`
4. Edit configuration: `nano ~/.config/borgctl.conf`
5. Set secure permissions: `chmod 600 ~/.config/borgctl.conf`
6. Initialize repository: `./borgctl.sh repo init`

## Configuration
Configuration files are read from:
- `/etc/borgctl.conf` (system-wide)
- `~/.config/borgctl.conf` (user-specific, overrides system)

Run `./borgctl.sh init-config` to generate an example configuration.

## Usage

### Backup Operations
```bash
# Create full backup
./borgctl.sh backup create

# Create backup of specific path
./borgctl.sh backup create /home/user

# Create backup with custom suffix
./borgctl.sh backup create "" mysuffix

# List all backups
./borgctl.sh backup list

# Delete specific backup(s)
./borgctl.sh backup delete archive-name-1 archive-name-2

# Interactive archive deletion
./borgctl.sh backup delete

# Mount repository
./borgctl.sh backup mount

# Mount specific archive
./borgctl.sh backup mount archive-name

# Mount to custom location
./borgctl.sh backup mount archive-name /mnt/custom

# Interactive archive mounting
./borgctl.sh backup mount

# Restore from backup
./borgctl.sh backup restore archive-name /restore/path

# Restore specific path from backup
./borgctl.sh backup restore archive-name /restore/path /original/path
```

### Repository Operations
```bash
# Initialize new repository
./borgctl.sh repo init

# Show repository info
./borgctl.sh repo info

# Check repository health
./borgctl.sh repo health-check

# Perform maintenance (prune + compact)
./borgctl.sh repo maintain

# Check for locks
./borgctl.sh repo lock-check

# Break lock (use with caution!)
./borgctl.sh repo lock-break
```

### Other Commands
```bash
# Show help
./borgctl.sh --help

# Enable debug mode (shows all commands)
./borgctl.sh -v backup create

# Generate bash completion
./borgctl.sh completion > /etc/bash_completion.d/borgctl

# Show this README
./borgctl.sh readme

# Initialize configuration
./borgctl.sh init-config
```

## Exit Codes
- 0: Success
- 1: General error
- 2: Configuration error
- 3: SSH connection error
- 4: Borg operation error
- 5: Lock conflict
- 6: Resource error (disk space, etc.)
- 10: User aborted operation

## Hooks
You can define hooks in your configuration file:

```bash
# Run before backup (e.g., stop services)
pre_backup_cmd="systemctl stop myapp"

# Run after successful backup (e.g., start services)
post_backup_cmd="systemctl start myapp"
```

## Monitoring
borgctl supports health check monitoring via HTTP endpoints:

```bash
# Ping on success
heartbeat_success_url="https://hc-ping.com/your-uuid"

# Ping on failure
heartbeat_failure_url="https://hc-ping.com/your-uuid/fail"
```

## Email Notifications
Configure email recipient to receive backup reports:

```bash
mail_recipient="admin@example.com"
```

## Cron Integration
Example crontab for daily backups:

```cron
# Daily backup at 2 AM
0 2 * * * /usr/local/bin/borgctl.sh backup create

# Weekly maintenance on Sundays at 3 AM
0 3 * * 0 /usr/local/bin/borgctl.sh repo maintain
```

## Troubleshooting

### Permission denied on config file
Ensure config file has 0600 permissions:
```bash
chmod 600 ~/.config/borgctl.conf
```

### SSH connection fails
Test SSH connection manually:
```bash
ssh -p PORT -i KEYFILE user@host
```

### Repository locked
Check for stale locks:
```bash
./borgctl.sh repo lock-check
```

Break lock if no other process is running:
```bash
./borgctl.sh repo lock-break
```

### Backup timeout
Increase timeout in configuration:
```bash
borg_operation_timeout="7200"  # 2 hours
```

## Security Considerations
- Always use SSH key authentication
- Keep passphrase secure (consider using keyring)
- Set config file permissions to 0600
- Use encrypted repository (repokey mode)
- Regularly test restores

## License
This script is provided as-is without warranty.

## Author
Version 20251013.03
EOF
}

#====================[ self-update ]====================
# Perform script self-update
# Args: $1=script_name, $2=update_base_url
run_self_update() {
    local self="$1"
    local update_base="$2"
    local script_path
    script_path=$(realpath "$0" 2>/dev/null || echo "$0")
    local script_name
    script_name=$(basename "$script_path")

    echo "Performing self-update"

    echo -ne "\r[ ] Downloading latest version..."
    if ! wget --quiet --output-document="${script_name}.tmp" "${update_base}/${self}"; then
        echo -e "\r[${RED}${CROSSMARK}${NC}] Downloading latest version"
        echo "[${RED}${CROSSMARK}${NC}] Performing self-update"
        exit "$EXIT_GENERAL_ERROR"
    fi
    echo -e "\r[${GREEN}${CHECKMARK}${NC}] Downloading latest version"

    echo -ne "\r[ ] Copying over modes from old version..."
    local octal_mode
    octal_mode=$(stat -c '%a' "$script_path" 2>/dev/null || echo "755")
    if ! chmod "$octal_mode" "${script_name}.tmp"; then
        echo -e "\r[${RED}${CROSSMARK}${NC}] Copying over modes from old version"
        echo "[${RED}${CROSSMARK}${NC}] Performing self-update"
        exit "$EXIT_GENERAL_ERROR"
    fi
    echo -e "\r[${GREEN}${CHECKMARK}${NC}] Copying over modes from old version"

    echo -ne "\r[ ] Start update process..."
    cat > updateScript.sh <<EOF
#!/bin/bash
if mv "${script_name}.tmp" "${script_path}"; then
    printf "\r\033[0KUpdate complete.\n"
    rm -f "\${0}"
else
    printf "\r\033[0KUpdate failed. Please try again!\n"
    rm -f "\${0}"
fi
EOF
    chmod +x updateScript.sh
    exec /bin/bash updateScript.sh
}

# Check for script updates
check_self_update() {
    local self
    self=$(basename "${0}")
    local update_base="${UPDATE_BASE:-https://to_be_set/}"
    
    local myself_web_version
    myself_web_version=$(curl -s -r 0-50 "${update_base}${self}" | head -2 | grep -E -o "([0-9]{8}\.[0-9]{2})")
    log_status "Web version: ${myself_web_version}" 1
    
    local myself_local_version
    myself_local_version=$(head -2 "${0}" | grep -E -o "([0-9]{8}\.[0-9]{2})")
    log_status "Local version: ${myself_local_version}" 1
    
    if [[ "${myself_web_version}" > "${myself_local_version}" ]]; then
        log_status "${YELLOW}New version v.${myself_local_version} to v.${myself_web_version} available.${NC}" 1
        read -rp "Update [y/N] " -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            run_self_update "${self}" "${update_base}"
        fi
    else
        log_status "No update available: v.${myself_local_version}" 1
    fi
}

#====================[ bash completion ]====================
# Print bash completion script
print_completion() {
echo "# Save this output to enable bash completion for borgctl:"
echo "# System-wide: sudo borgctl completion > /etc/bash_completion.d/borgctl"
echo "# User-only:   borgctl completion > ~/.local/share/bash-completion/completions/borgctl"
echo "# Then reload: source /etc/bash_completion or restart your shell"
echo ""
cat <<'COMP'
# bash completion for borgctl
_borgctl_complete() {
  local cur prev words cword
  _init_completion -n : || return

  local sub1="backup repo completion help init-config readme"
  local backup_sub="create delete list mount restore"
  local repo_sub="init info health-check maintain lock-check lock-break"

  if [[ ${cword} -eq 1 ]]; then
    COMPREPLY=( $(compgen -W "${sub1}" -- "$cur") )
    return
  fi
  
  case "${words[1]}" in
    backup) 
      COMPREPLY=( $(compgen -W "${backup_sub}" -- "$cur") )
      ;;
    repo)   
      COMPREPLY=( $(compgen -W "${repo_sub}" -- "$cur") )
      ;;
    *)      
      COMPREPLY=()
      ;;
  esac
}
complete -F _borgctl_complete borgctl
COMP
}

#====================[ help ]====================
# Display help information
show_help() {
    local b="" nb=""
    # Only use bold if we have a TTY and NO_COLOR is not set
    if [[ -t 1 && -z "${NO_COLOR:-}" ]]; then
        b='\033[1m'
        nb='\033[0m'
    fi
    
    echo -e "${b}1. Usage:${nb}"
    echo "  $0 [OPTION] <backup|repo|completion|init-config|readme|help> <subcommand> [Arguments...]"
    echo
    echo -e "${b}2. Commands:${nb}"
    echo
    echo -e "  ${b}Backup Operations:${nb}"
    echo "    backup create [path] [suffix]      Create backup (optional path and suffix)"
    echo "    backup delete [arc_1] [arc_2] ...  Delete backup(s) - interactive if no args"
    echo "    backup list                        List all backups"
    echo "    backup mount [archive] [path]      Mount repository or specific archive"
    echo "    backup restore <arc> <dest> [path] Restore from backup"
    echo
    echo -e "  ${b}Repository Operations:${nb}"
    echo "    repo init                          Initialize repository"
    echo "    repo info                          Show repository info"
    echo "    repo health-check                  Check repository integrity"
    echo "    repo maintain                      Maintenance job (prune + compact)"
    echo "    repo lock-check                    Check for repository locks"
    echo "    repo lock-break                    Break repository lock (use with caution!)"
    echo
    echo -e "  ${b}Configuration & Help:${nb}"
    echo "    init-config                        Interactive config file generator"
    echo "    completion                         Print bash completion to stdout"
    echo "    readme                             Display full documentation"
    echo "    help, --help                       Show this help"
    echo
    echo -e "${b}3. Options:${nb}"
    echo "  -v          Debug mode (show commands and variables)"
    echo "  -u          Self-update (check for new version)"
    echo
    echo -e "${b}4. Configuration:${nb}"
    echo "  Reads configuration from:"
    echo "    - ${GLOBAL_CONFIG} (global, system-wide)"
    echo "    - ${USER_CONFIG} (user-specific, overrides global)"
    echo
    echo "  Create config with: $0 init-config"
    echo
    echo -e "${b}5. Exit Codes:${nb}"
    echo "  0  = Success"
    echo "  1  = General error"
    echo "  2  = Configuration error"
    echo "  3  = SSH connection error"
    echo "  4  = Borg operation error"
    echo "  5  = Lock conflict"
    echo "  6  = Resource error (disk space, etc.)"
    echo "  10 = User aborted operation"
    echo
    echo -e "${b}6. Examples:${nb}"
    echo "  $0 backup create                   # Full backup"
    echo "  $0 backup create /home mybackup    # Backup /home with suffix"
    echo "  $0 backup mount                    # Interactive mount"
    echo "  $0 backup restore arch-name /tmp   # Restore to /tmp"
    echo "  $0 -v repo maintain                # Maintenance with debug output"
    echo
    echo "For detailed documentation, run: $0 readme"
}

#====================[ main ]====================
# Main function to handle command routing
main() {
    if [[ $# -eq 0 || "$1" == "--help" || "$1" == "help" ]]; then
        show_help
        exit "$EXIT_SUCCESS"
    fi

    if [[ "$1" == "-u" ]]; then
        check_self_update
        exit "$EXIT_SUCCESS"
    fi

    case "$1" in
        backup)
            case "${2:-}" in
                create)       
                    shift 2
                    backup_create "$@"
                    exit $?
                    ;;
                delete)       
                    shift 2
                    if [[ $# -eq 0 ]]; then
                        select_archive_interactive "delete"
                    else
                        backup_delete "$@"
                    fi
                    exit $?
                    ;;
                list)         
                    shift 2
                    backup_list_and_mail "$@"
                    exit $?
                    ;;
                mount)        
                    shift 2
                    if [[ $# -eq 0 ]]; then
                        select_archive_interactive "mount"
                    else
                        backup_mount "$@"
                    fi
                    exit $?
                    ;;
                restore)
                    shift 2
                    backup_restore "$@"
                    exit $?
                    ;;
                *)            
                    show_help
                    exit "$EXIT_GENERAL_ERROR"
                    ;;
            esac
            ;;
        repo)
            case "${2:-}" in
                init)         
                    shift 2
                    repo_init "$@"
                    exit $?
                    ;;
                info)         
                    shift 2
                    repo_info "$@"
                    exit $?
                    ;;
                health-check) 
                    shift 2
                    repo_health_check "$@"
                    exit $?
                    ;;
                maintain)     
                    shift 2
                    repo_maintain "$@"
                    exit $?
                    ;;
                lock-check)   
                    shift 2
                    repo_lock_check "$@"
                    exit $?
                    ;;
                lock-break)   
                    shift 2
                    repo_lock_break "$@"
                    exit $?
                    ;;
                *)            
                    show_help
                    exit "$EXIT_GENERAL_ERROR"
                    ;;
            esac
            ;;
        completion)
            print_completion
            exit "$EXIT_SUCCESS"
            ;;
        init-config)
            init_config_wizard
            exit $?
            ;;
        readme)
            show_readme
            exit "$EXIT_SUCCESS"
            ;;
        *)
            show_help
            exit "$EXIT_GENERAL_ERROR"
            ;;
    esac
}

# Call main function with all arguments
main "$@"

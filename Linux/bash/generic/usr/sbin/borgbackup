#!/bin/bash
# Version=20250608.01

GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m'

GLOBAL_CONFIG="/etc/borgbackup.conf"
USER_CONFIG="$HOME/.config/borgbackup/borgbackup.conf"

variables_initialized=false

# --- Logging ---
log_status() {
    local msg="$1"
    local newline="${2:-0}" # 0 = keine neue Zeile, 1 = mit neuer Zeile
    if [[ "$newline" == "1" ]]; then
        echo -e "\r$msg"
    else
        echo -ne "\r$msg"
    fi
}

debug_msg() {
    if [[ "$debug" == "1" ]]; then
        log_status "  ${YELLOW}\$ $*${NC}" 1
    fi
}

# --- Config permissions check ---
check_config_permissions() {
    local cfg="$1"
    if [[ -f "$cfg" ]]; then
        local mode
        mode=$(stat -c "%a" "$cfg")
        if [[ "$mode" != "600" ]]; then
            log_status "[${RED}✗${NC}] Config file $cfg must have permissions 0600, but has $mode" 1
            exit 10
        fi
    fi
}

check_config_permissions "$GLOBAL_CONFIG"
check_config_permissions "$USER2_CONFIG" 2>/dev/null || true

debug=0

args=()
for arg in "$@"; do
    if [[ "$arg" == "-v" ]]; then
        debug=1
    else
        args+=("$arg")
    fi
done
set -- "${args[@]}"

# --- Config loading ---
config_loaded=0
if [[ -f "$GLOBAL_CONFIG" ]]; then
    source "$GLOBAL_CONFIG"
    config_loaded=1
fi
if [[ -f "$USER_CONFIG" ]]; then
    source "$USER_CONFIG"
    config_loaded=1
fi

if [[ "$config_loaded" -eq 0 ]]; then
    log_status "[${RED}✗${NC}] No configuration file found!" 1
    exit 10
fi

if [[ "${BORG_RELOCATED_REPO_ACCESS_IS_OK:-no}" == "yes" ]]; then
    export BORG_RELOCATED_REPO_ACCESS_IS_OK=yes
fi

if [[ -z "${ssh_remote_host:-}" || -z "${ssh_remote_user:-}" || -z "${ssh_remote_folder:-}" || -z "${borg_backup_name_format:-}" ]]; then
    log_status "[${RED}✗${NC}] No valid configuration found!" 1
    exit 10
fi

run_cmd() {
    local cmd="$*"
    debug_msg "$cmd"
    eval "$cmd"
    return $?
}

tempfile() {
    umask 077
    mktemp "/tmp/$(basename "$0").XXXXXX"
}

escape_mail_subject() {
    printf "%s" "$1" | sed "s/'/'\"'\"'/g"
}

set_variables() {
    local job_name="${1:-full}"
    if [[ "$variables_initialized" == false ]]; then
        export BORG_PASSPHRASE="${borg_passphrase}"
        export BORG_RSH="ssh -p ${ssh_remote_port} -oStrictHostKeyChecking=no -oBatchMode=yes -i ${ssh_remote_authfile}"
        temp=$(tempfile)
        variables_initialized=true
        log_status "[${GREEN}✓${NC}] Variables set for backup job [${job_name}]" 1
        debug_msg "BORG_RSH=${BORG_RSH}"
        debug_msg "temp=${temp}"
    fi
    snapshot_name=$(date +"$borg_backup_name_format" | sed 's/^$(date +%Y-%m-%d)-full//')
    if [[ "$borg_backup_name_format" == *'%'* ]]; then
        snapshot_name=$(date +"$borg_backup_name_format")
    else
        snapshot_name=$(eval echo "$borg_backup_name_format")
    fi
    if [[ -n "${default_backup_prefix:-}" ]]; then
        snapshot_name="${snapshot_name}_${default_backup_prefix}"
    fi
    debug_msg "snapshot_name=${snapshot_name}"
    debug_msg "repo_name=${repo_name:-}"
}

repo_name=$(eval echo "${borg_repo_name_format:-}")
if [[ -n "$repo_name" ]]; then
    repo_path="${ssh_remote_user}@${ssh_remote_host}:${ssh_remote_folder}${repo_name}"
else
    repo_path="${ssh_remote_user}@${ssh_remote_host}:${ssh_remote_folder}"
fi

# --- Backup functions ---
backup_create() {
    local include_path="${1:-}"
    local backup_suffix="${2:-}"
    set_variables "full"
    repo_lock_check || exit 2
    local msg="[ ] Creating backup"
    log_status "$msg"
    local borg_create_opts=(--exclude-caches --exclude-nodump --compression "${compression}" "${exclude_args[@]}")
    local -a include_paths=("${backup_paths[@]}")
    [[ -n "$include_path" ]] && include_paths=("$include_path")
    [[ ${#include_paths[@]} -eq 0 ]] && include_paths=("/")
    # Suffix überschreibt default_backup_prefix, wenn angegeben
    if [[ -n "$backup_suffix" ]]; then
        snapshot_name="$(date +"$borg_backup_name_format" | sed 's/^$(date +%Y-%m-%d)-full//')"
        if [[ "$borg_backup_name_format" == *'%'* ]]; then
            snapshot_name="$(date +"$borg_backup_name_format")"
        else
            snapshot_name=$(eval echo "$borg_backup_name_format")
        fi
        snapshot_name="${snapshot_name}_${backup_suffix}"
    fi
    debug_msg "borg create ${borg_create_opts[*]} --stats --progress ${repo_path}::${snapshot_name} ${include_paths[*]}"
    borg create "${borg_create_opts[@]}" --stats --progress "${repo_path}::${snapshot_name}" "${include_paths[@]}"
    local rc=$?
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}✓${NC}] Creating backup (suffix: ${backup_suffix:-${default_backup_prefix:-none}})" 1
        local report_file
        report_file=$(tempfile)
        debug_msg "borg info ${repo_path}::${snapshot_name} > $report_file"
        borg info "${repo_path}::${snapshot_name}" > "$report_file"
        if [[ -n "${mail_recipient:-}" ]]; then
            local subject="$(hostname) backup - [${snapshot_name}]"
            debug_msg "mail -s \"$subject\" \"${mail_recipient}\" < \"$report_file\""
            mail -s "$subject" "${mail_recipient}" < "$report_file"
        fi
        rm -f "$report_file"
    else
        log_status "[${RED}✗${NC}] Creating backup (suffix: ${backup_suffix:-${default_backup_prefix:-none}})" 1
        exit 2
    fi
}

backup_delete() {
    local archive_name="$1"
    set_variables "full"
    if [[ -z "$archive_name" ]]; then
        log_status "[${RED}✗${NC}] No archive name specified for deletion!" 1
        exit 2
    fi
    local msg="[ ] Deleting backup $archive_name"
    log_status "$msg"
    debug_msg "borg delete -v ${repo_path}::${archive_name}"
    borg delete -v "${repo_path}::${archive_name}"
    local rc=$?
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}✓${NC}] Deleting backup $archive_name" 1
        if [[ -n "${mail_recipient:-}" ]]; then
            local subject="$(hostname) backup deleted - [${archive_name}]"
            local mailfile
            mailfile=$(tempfile)
            echo "Backup deleted: ${archive_name}" > "$mailfile"
            debug_msg "borg info $repo_path >> $mailfile"
            borg info "$repo_path" >> "$mailfile"
            debug_msg "mail -s \"$subject\" \"${mail_recipient}\" < \"$mailfile\""
            mail -s "$subject" "${mail_recipient}" < "$mailfile"
            rm -f "$mailfile"
        fi
    else
        log_status "[${RED}✗${NC}] Deleting backup $archive_name" 1
        exit 2
    fi
}

backup_list_and_mail() {
    set_variables "full"
    local msg="[ ] Listing all backups"
    log_status "$msg"
    local mailfile
    mailfile=$(tempfile)
    debug_msg "borg list $repo2_path | tee $mailfile"
    borg list "$repo_path" | tee "$mailfile"
    local rc=$?
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}✓${NC}] Listing all backups" 1
        if [[ -n "${mail_recipient:-}" ]]; then
            local subject="$(hostname) backup list - [${repo_name}]"
            debug_msg "mail -s \"$subject\" \"${mail_recipient}\" < \"$mailfile\""
            mail -s "$subject" "${mail_recipient}" < "$mailfile"
        fi
    else
        log_status "[${RED}✗${NC}] Listing all backups" 1
        exit 2
    fi
    rm -f "$mailfile"
}

backup_mount() {
    local archive="${1:-}"
    set_variables "full"
    local mountpoint="${borg_mount_point:-/mnt/borgbackup_mount}"
    local msg
    if [[ -n "$archive" ]]; then
        msg="[ ] Mounting archive $archive"
    else
        msg="[ ] Mounting repository read-only"
    fi
    log_status "$msg"
    [[ ! -d "$mountpoint" ]] && debug_msg "mkdir -p \"$mountpoint\"" && mkdir -p "$mountpoint"
    if [[ -n "$archive" ]]; then
        debug_msg "borg mount \"${repo_path}::${archive}\" \"$mountpoint\""
        borg mount "${repo_path}::${archive}" "$mountpoint"
    else
        debug_msg "borg mount \"$repo_path\" \"$mountpoint\""
        borg mount "$repo_path" "$mountpoint"
    fi
    local rc=$?
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}✓${NC}] ${msg:4}" 1
        echo "Unmount with: borg umount $mountpoint"
    else
        log_status "[${RED}✗${NC}] ${msg:4}" 1
        exit 2
    fi
}

# --- Repo functions ---
repo_init() {
    set_variables "full"
    local msg="[ ] Initializing repository"
    log_status "$msg"
    debug_msg "borg init -e repokey \"$repo_path\""
    borg init -e repokey "$repo_path"
    local rc=$?
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}✓${NC}] Initializing repository" 1
    else
        log_status "[${RED}✗${NC}] Initializing repository" 1
        exit 2
    fi
}

repo_health_check() {
    set_variables "full"
    local msg="[ ] Checking repository health"
    log_status "$msg"
    debug_msg "borg check \"$repo_path\""
    borg check "$repo_path"
    local rc=$?
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}✓${NC}] Checking repository health" 1
    else
        log_status "[${RED}✗${NC}] Checking repository health" 1
        exit 2
    fi
}

repo_compact() {
    set_variables "full"
    local msg="[ ] Compacting repository"
    log_status "$msg"
    debug_msg "borg compact \"$repo_path\""
    borg compact "$repo_path"
    local rc=$?
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}✓${NC}] Compacting repository" 1
    else
        log_status "[${RED}✗${NC}] Compacting repository" 1
        exit 2
    fi
}

repo_lock_check() {
    set_variables "full"
    local msg="[ ] Lock check"
    log_status "$msg"
    debug_msg "borg info \"$repo_path\""
    local repostatus
    repostatus=$(borg info "$repo_path" 2>&1)
    if [[ "${repostatus}" == *"Failed to create/acquire the lock"* ]]; then
        log_status "[${RED}✗${NC}] Lock check" 1
        return 1
    fi
    log_status "[${GREEN}✓${NC}] Lock check" 1
    return 0
}

repo_lock_break() {
    set_variables "full"
    local msg="[ ] Breaking repository lock"
    log_status "$msg"
    debug_msg "borg break-lock \"$repo_path\""
    borg break-lock "$repo_path"
    local rc=$?
    if [[ $rc -eq 0 ]]; then
        log_status "[${GREEN}✓${NC}] Breaking repository lock" 1
    else
        log_status "[${RED}✗${NC}] Breaking repository lock" 1
        exit 2
    fi
}

# --- Self-update placeholder ---
script_self_update() {
    local msg="[ ] Performing self-update"
    log_status "$msg"
    sleep 2
    log_status "[${GREEN}✓${NC}] Performing self-update" 1
}

# --- Help ---
show_help() {
cat <<EOF
Usage:
  $0 [OPTION] <backup|repo> <subcommand> [Arguments...]

Commands:
  backup create [path] [suffix]    Create backup (optional path and suffix)
  backup delete [archive]          Delete backup
  backup list                      List backups
  backup mount [archive]           Mount backup/repository

  repo init                        Initialize repository
  repo health-check                Check repository health
  repo compact                     Compact repository
  repo lock-check                  Check for locks
  repo lock-break                  Break lock

Options:
  -v      Debug mode (show commands and variables in yellow)
  -u      Self-update
  --help  Show this help

Examples:
  $0 backup create /home
  $0 backup create /home custom_suffix
  $0 repo init
  $0 backup mount 2025-06-08_14-30_custom

Config:
The script reads configuration from two files:
- ${GLOBAL_CONFIG} (global, system-wide)
- ${USER_CONFIG} (user-specific, overrides global settings)

All settings from the user-specific config file override those from the global config.
EOF
}

# --- Main logic ---
if [[ $# -eq 0 || "$1" == "--help" ]]; then
    show_help
    exit 0
fi

if [[ "$1" == "-u" ]]; then
    script_self_update
    exit 0
fi

case "$1" in
    backup)
        case "$2" in
            create)       shift 2; backup_create "$@" ;;
            delete)       shift 2; backup_delete "$@" ;;
            list)         shift 2; backup_list_and_mail "$@" ;;
            mount)        shift 2; backup_mount "$@" ;;
            *)            show_help; exit 1 ;;
        esac
        ;;
    repo)
        case "$2" in
            init)         shift 2; repo_init "$@" ;;
            health-check) shift 2; repo_health_check "$@" ;;
            compact)      shift 2; repo_compact "$@" ;;
            lock-check)   shift 2; repo_lock_check "$@" ;;
            lock-break)   shift 2; repo_lock_break "$@" ;;
            *)            show_help; exit 1 ;;
        esac
        ;;
    *)
        show_help
        exit 1
        ;;
esac

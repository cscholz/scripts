#!/bin/bash
# Version=20251010.01
# Wrapper to manage dns zones
set -euo pipefail

# --- Colors / Styles ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m'
BOLD='\033[1m'
NOBOLD='\033[0m'

CHECKMARK="✓"
CROSSMARK="✗"

# --- Script / Config names ---
SCRIPT_NAME="$(basename "$0")"
CONFIG_NAME="${SCRIPT_NAME%.sh}.conf"
GLOBAL_CONFIG="/etc/${CONFIG_NAME}"
USER_CONFIG="$HOME/.config/${CONFIG_NAME}"

# --- Logging ---
log_status() {
    local msg="$1"
    local newline="${2:-0}" # 0=no newline; 1=newline
    if [[ "$newline" == "1" ]]; then
        echo -e "\r$msg"
    else
        echo -ne "\r$msg"
    fi
}

debug=0
debug_msg() {
    if [[ "$debug" == "1" ]]; then
        log_status "  ${YELLOW}\$ $*${NC}" 1
    fi
}

# --- Config permissions check (0600) ---
check_config_permissions() {
    local cfg="$1"
    if [[ -f "$cfg" ]]; then
        local mode
        mode=$(stat -c "%a" "$cfg")
        if [[ "$mode" != "600" ]]; then
            log_status "[${RED}${CROSSMARK}${NC}] Config file $cfg must have permissions 0600, but has $mode" 1
            exit 10
        fi
    fi
}

# --- Package check / optional install ---
checkpackage() {
  local exec="$1"
  local pkg="$2"
  if ! command -v "$exec" >/dev/null 2>&1; then
    echo -e "${RED}Package \"$pkg\" not found!${NC}"
    read -p "Install? (y/N) " -r
    if [[ ${REPLY:-N} =~ ^[Yy]$ ]]; then
      sudo apt-get update
      sudo apt-get install -y "$pkg"
    else
      exit 1
    fi
  fi
}

# --- Key permissions (0600) ---
check_key_permissions() {
  local keyfile="$1"
  if [[ ! -f "$keyfile" ]]; then
    echo -e "${RED}Key file does not exist: $keyfile${NC}"
    exit 1
  fi
  local perms
  perms=$(stat -c "%a" "$keyfile")
  if [[ "$perms" != "600" ]]; then
    echo -e "${RED}Key file $keyfile must have permissions 0600 (current: $perms). No updates performed!${NC}"
    exit 1
  fi
}

# --- Defaults (can be overridden by config and CLI) ---
dns_server=""
dns_key=""
ip_detect_url=""
record_type="A"
ttl="3600"
dns_class="IN"
ip_version="ipv4"
use_public_ip_target=0
target_value=""
pre_update_cmd=""
auto_overwrite_existing_records="n"
interactive=0
record_type_was_explicit=0
dns_key_was_explicit=0

# --- Load configs (global then user; user overrides) ---
check_config_permissions "$GLOBAL_CONFIG"
check_config_permissions "$USER_CONFIG"
[[ -f "$GLOBAL_CONFIG" ]] && source "$GLOBAL_CONFIG"
[[ -f "$USER_CONFIG"   ]] && source "$USER_CONFIG"

# --- Helpers ---
print_aligned() {
  local key="$1"
  local value="${2:-}"
  printf "%-15s %s\n" "$key:" "$value"
}

# --- Usage (original + only -i added) ---
usage() {
  echo -e "\033[1;4m1. Usage:\033[0m"
  echo "   ${SCRIPT_NAME} [Global Parameter] <command> [Parameter] [Arguments...]"
  echo
  echo -e "\033[1;4m2. Config:\033[0m"
  echo "   - /etc/${CONFIG_NAME} (global, system-wide)"
  echo "   - ~/.config/${CONFIG_NAME} (user-specific)"
  echo "   User config overrides global config."
  echo "   CLI parameters override both config files."
  echo
  echo -e "\033[1;4m3. Global Parameter:\033[0m"
  echo "   -u             Self-update"
  echo "   --help         Show this help"
  echo "   -v             Debug mode (show commands and variables in yellow)"
  echo "   -i             Interactive mode (guided prompts)"
  echo
  echo -e "\033[1;4m4. Commands:\033[0m"
  echo "   # Zone commands"
  echo "   soa-get <Zone>                           Show SOA record for the zone (nicely formatted)"
  echo "   soa-set <Zone> [primary] [email] [serial] [refresh] [retry] [expire] [minimum]"
  echo "                                            Set all SOA parameters for a zone. Old SOA will be replaced."
  echo "   soa-set-serial <Zone> <serial>           Update only the SOA serial for the zone"
  echo "   soa-set-refresh <Zone> <refresh>         Update only the SOA refresh value"
  echo "   soa-set-retry <Zone> <retry>             Update only the SOA retry value"
  echo "   soa-set-expire <Zone> <expire>           Update only the SOA expire value"
  echo "   soa-set-minimum <Zone> <minimum>         Update only the SOA minimum value"
  echo "   listzone <Zone>                          List all records of a DNS zone (zone transfer/AXFR, DNSSEC entries filtered)"
  echo "                                            Only the first dig output block is shown. DNSSEC (RRSIG/NSEC/DNSKEY) entries are excluded."
  echo "                                            Note: Only possible if the DNS server allows AXFR for your client IP."
  echo "   listzone_full <Zone>                     List all records of a DNS zone (zone transfer/AXFR, all records, no filtering)"
  echo
  echo "   # Record commands"
  echo "   add <Record Name> <Zone>                 Add or update a DNS record"
  echo "   del <Record Name> <Zone>                 Delete a DNS record"
  echo "   check <Record Name> <Zone>               Show DNS record and TXT record for a name"
  echo
  echo -e "\033[1;4m5a. Zone Parameter:\033[0m"
  echo "   For soa-set and subcommands:"
  echo "     primary      Primary nameserver for the zone (default: ns1.<zone>.)"
  echo "     email        Email address for the zone (default: hostmaster.<zone>.)"
  echo "     serial       Serial number (default: YYYYMMDD01)"
  echo "     refresh      Refresh interval (default: 86400)"
  echo "     retry        Retry interval (default: 7200)"
  echo "     expire       Expire value (default: 3600000)"
  echo "     minimum      Minimum TTL (default: 172800)"
  echo
  echo -e "\033[1;4m5b. Zone Examples:\033[0m"
  echo "   1) \$ ${SCRIPT_NAME} soa-get example.com"
  echo "   2) \$ ${SCRIPT_NAME} soa-set example.com ns1.example.com. hostmaster.example.com. 2024062501 3600 600 86400 60"
  echo "   3) \$ ${SCRIPT_NAME} soa-set-serial example.com 2024062502"
  echo "   4) \$ ${SCRIPT_NAME} soa-set-refresh example.com 7200"
  echo "   5) \$ ${SCRIPT_NAME} listzone example.com"
  echo
  echo -e "\033[1;4m6a. Record Parameter:\033[0m"
  echo "   -dns-server <server>      DNS server to use (default from config)"
  echo "   -key <keyfile>            Path to nsupdate key (default from config)"
  echo "   -ip-detect <url>          URL to retrieve public IP (default: https://api.ipify.org)"
  echo "   -type <recordtype>        DNS record type (A, AAAA, MX, NS, TXT, etc.; default: A)"
  echo "   -ttl <seconds>            TTL for the record (default: 3600)"
  echo "   -class <class>            DNS class (default: IN)"
  echo "   -ipv4                     Use IPv4 (default)"
  echo "   -ipv6                     Use IPv6"
  echo "   -target-public-ip         Use your current public IP as the target value (A/AAAA)"
  echo "   -target <value>           Set target value for record (e.g. for MX, NS, TXT, CNAME, SRV, PTR)"
  echo "   -y                        Automatically overwrite existing records (default: n)"
  echo
  echo -e "\033[1;4m6b. Record Examples:\033[0m"
  echo "   1) dsl.example.com. 3600 IN A 203.0.113.42"
  echo "      \$ ${SCRIPT_NAME} add dsl example.com"
  echo
  echo "   2) dsl.example.com. 60 IN A 198.51.100.42"
  echo "      \$ ${SCRIPT_NAME} add dsl example.com -target-public-ip -ttl 60"
  echo
  echo "   3) spf.example.com. 3600 IN TXT \"v=spf1 include:_spf.example.com ~all\""
  echo "      \$ ${SCRIPT_NAME} add spf example.com -type TXT -target '\"v=spf1 include:_spf.example.com ~all\"'"
  echo
  echo "   4) www.example.com. 3600 IN CNAME example.com."
  echo "      \$ ${SCRIPT_NAME} add www example.com -type CNAME -ttl 3600 -class IN -dns-server ns1.example.com -key /root/${SCRIPT_NAME}.key -target \"example.com.\""
  echo
  echo "   5) example.com. 3600 IN MX 10 mail.example.com."
  echo "      \$ ${SCRIPT_NAME} add @ example.com -type MX -target \"10 mail.example.com.\""
  echo
}

# --- DIG / NSUPDATE wrappers ---
get_zone_soa() {
    local zone="$1"
    local server="${dns_server}"
    checkpackage dig dnsutils
    debug_msg dig +short SOA "${zone}." @"${server}"
    local soa
    soa=$(dig +short SOA "${zone}." @"${server}" || true)
    if [[ -z "${soa}" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] No SOA record found for zone ${zone}." 1
        return 1
    fi
    local primary email serial refresh retry expire minimum
    read -r primary email serial refresh retry expire minimum <<<"$soa"
    printf "%-12s: %s\n" "Primary" "$primary"
    printf "%-12s: %s\n" "Email"   "$email"
    printf "%-12s: %s\n" "Serial"  "$serial"
    printf "%-12s: %s\n" "Refresh" "$refresh"
    printf "%-12s: %s\n" "Retry"   "$retry"
    printf "%-12s: %s\n" "Expire"  "$expire"
    printf "%-12s: %s\n" "Minimum" "$minimum"
}

set_zone_soa() {
    local zone="$1"
    local primary="${2:-}"
    local email="${3:-}"
    local serial="${4:-}"
    local refresh="${5:-}"
    local retry="${6:-}"
    local expire="${7:-}"
    local minimum="${8:-}"
    local server="${dns_server}"
    local key="${dns_key}"
    local class="IN"

    checkpackage nsupdate dnsutils
    [[ -z "$primary" ]] && primary="ns1.${zone}."
    [[ -z "$email"   ]] && email="hostmaster.${zone}."
    [[ -z "$serial"  ]] && serial="$(date +%Y%m%d)01"
    [[ -z "$refresh" ]] && refresh=86400
    [[ -z "$retry"   ]] && retry=7200
    [[ -z "$expire"  ]] && expire=3600000
    [[ -z "$minimum" ]] && minimum=172800

    local commands="server ${server}
zone ${zone}
update delete ${zone}. ${class} SOA
update add ${zone}. 3600 ${class} SOA ${primary} ${email} ${serial} ${refresh} ${retry} ${expire} ${minimum}
send
"
    debug_msg echo -e "${commands} | /usr/bin/nsupdate -k ${key}"
    echo -e "${commands}" | /usr/bin/nsupdate -k "${key}"

    if [[ $? -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] SOA updated for zone ${zone}." 1
    else
        log_status "[${RED}${CROSSMARK}${NC}] SOA update failed for zone ${zone}." 1
        return 1
    fi
}

_set_from_existing_soa_and_apply() {
    local zone="$1" field="$2" value="$3"
    local server="${dns_server}"
    checkpackage dig dnsutils
    debug_msg dig +short SOA "${zone}." @"${server}"
    local old_soa primary email serial refresh retry expire minimum
    old_soa=$(dig +short SOA "${zone}." @"${server}" || true)
    [[ -z "$old_oa" && -z "$old_soa" ]] && { echo "No SOA found!"; return 1; }
    [[ -z "$old_soa" ]] && old_soa="$old_oa"
    read -r primary email serial refresh retry expire minimum <<<"$old_soa"
    case "$field" in
      serial)  serial="$value" ;;
      refresh) refresh="$value" ;;
      retry)   retry="$value" ;;
      expire)  expire="$value" ;;
      minimum) minimum="$value" ;;
    esac
    set_zone_soa "$zone" "$primary" "$email" "$serial" "$refresh" "$retry" "$expire" "$minimum"
}
set_zone_soa_serial()  { _set_from_existing_soa_and_apply "$1" "serial"  "$2"; }
set_zone_soa_refresh() { _set_from_existing_soa_and_apply "$1" "refresh" "$2"; }
set_zone_oa() { set_zone_soa "$@"; }  # typo-safe alias
set_zone_soa_retry()   { _set_from_existing_soa_and_apply "$1" "retry"   "$2"; }
set_zone_soa_expire()  { _set_from_existing_soa_and_apply "$1" "expire"  "$2"; }
set_zone_soa_minimum() { _set_from_existing_soa_and_apply "$1" "minimum" "$2"; }
_set_from_existing_oa_and_apply() { _set_from_existing_soa_and_apply "$@"; } # typo-safe alias

list_zone() {
  checkpackage dig dnsutils
  local zone="$1"
  local server="${dns_server}"
  echo "Attempting AXFR zone transfer for: $zone @ $server"
  echo "Note: This only works if the DNS server allows AXFR for your client IP."
  debug_msg dig "$zone" "AXFR" "@" "$server"
  dig "$zone" AXFR @"$server" | egrep -vi '(rrsig|nsec|dnskey)' | awk '!seen[$0]++'
}

list_zone_full() {
  checkpackage dig dnsutils
  local zone="$1"
  local server="${dns_server}"
  echo "Attempting AXFR zone transfer for: $zone @ $server"
  echo "Note: This only works if the DNS server allows AXFR for your client IP."
  debug_msg dig "$zone" "AXFR" "@" "$server"
  dig "$zone" AXFR @"$server" | awk '!seen[$0]++'
}

check_record() {
  checkpackage dig dnsutils
  local record="$1"
  local zone="$2"
  local fqdn
  if [[ "$record" == "@" ]]; then fqdn="${zone}"; else fqdn="${record}.${zone}"; fi
  local type="${record_type}"
  local server="${dns_server}"

  echo "Checking DNS records for: ${fqdn}."
  echo "-----------------------------------"
  print_aligned "$type" "$(dig "$type" "${fqdn}" @"${server}" +short 2>/dev/null | head -n1 || echo "n/a")"
  print_aligned "TXT"  "$(dig TXT "${fqdn}"  @"${server}" +short 2>/dev/null | head -n1 || echo "n/a")"
  echo "-----------------------------------"
}

dns_add_update() {
  checkpackage nsupdate dnsutils
  checkpackage curl curl
  local record="$1"
  local zone="$2"

  local fqdn
  if [[ "$record" == "@" ]]; then
    fqdn="${zone}."
  else
    fqdn="${record}.${zone}."
  fi
  local type="${record_type}"
  local server="${dns_server}"
  local key="${dns_key}"
  local url="${ip_detect_url:-https://api.ipify.org}"
  local ttl_val="${ttl}"
  local class="${dns_class}"
  local iptype="${ip_version}"
  local update=0

  check_key_permissions "$key"

  # Determine value
  local value=""
  local ip=""
  if [[ -n "${target_value}" ]]; then
    value="${target_value}"
  elif [[ "${use_public_ip_target}" -eq 1 || "$type" == "A" || "$type" == "AAAA" ]]; then
    local IPvX="4"
    if [[ "$type" == "AAAA" || "$iptype" == "ipv6" ]]; then IPvX="6"; fi
    debug_msg curl --connect-timeout 2 -"${IPvX}" --silent -f "${url}"
    ip=$(curl --connect-timeout 2 -"${IPvX}" --silent -f "${url}" || true)
    print_aligned "Public IPv${IPvX}" "${ip:-n/a}"
    if [[ -z "${ip}" ]]; then
      echo "Could not determine public IP. No internet connection?"
      logger -t "${SCRIPT_NAME}" "Could not determine public IP. No internet connection?"
      return 1
    fi
    value="$ip"
  fi

  echo "-----------------------------------------"
  print_aligned "DNS Zone"       "$zone"
  print_aligned "Record"         "$record"
  print_aligned "Type"           "$type"
  print_aligned "Class"          "$class"
  print_aligned "Target"         "$value"
  print_aligned "TTL"            "$ttl_val"
  print_aligned "FQDN"           "$fqdn"
  echo "-----------------------------------------"

  debug_msg dig "$type" "${fqdn%?}" "@" "$server" "+short"
  DNS_VAL=$(dig "$type" "${fqdn%?}" @"$server" +short 2>/dev/null || true)

  if [[ "${DNS_VAL}" == "${value}" && -n "${DNS_VAL}" ]]; then
    log_status "[-] Same target; not updated" 1
    return 0
  fi

  if [[ -n "${DNS_VAL}" ]]; then
    if [[ "$auto_overwrite_existing_records" == "y" ]]; then
      log_status "[ ] Deleting existing record..." 0
      local commands="server ${server}
zone ${zone}
update delete ${fqdn%?} ${class} ${type}
send
"
      debug_msg echo -e "${commands} | /usr/bin/nsupdate -k ${key}"
      echo -e "${commands}" | /usr/bin/nsupdate -k "${key}"
      log_status "\r[${GREEN}${CHECKMARK}${NC}] Deleting existing record" 1
      update=1
    else
      echo -en "${YELLOW}${BOLD}[?]${NOBOLD}${YELLOW}${NC} "
      read -p "Delete existing record before adding new one? (y/N) " -r
      if [[ ${REPLY:-N} =~ ^[Yy]$ ]]; then
        local commands="server ${server}
zone ${zone}
update delete ${fqdn%?} ${class} ${type}
send
"
        debug_msg echo -e "${commands} | /usr/bin/nsupdate -k ${key}"
        echo -e "${commands}" | /usr/bin/nsupdate -k "${key}"
        update=1
      else
        return 0
      fi
    fi
  fi

  if [[ -z "$value" ]]; then
    case "$type" in
      MX)   value="10 mail.${zone}." ;;
      NS)   value="ns1.${zone}." ;;
      TXT)  value="\"$(date +%d.%m.%Y,\ %H:%M:%S\ %Z\ \(%:::z\))\"" ;;
      CNAME)value="${zone}." ;;
      SRV)  value="10 60 5060 sipserver.${zone}." ;;
      PTR)  value="${zone}." ;;
      *)    value="$ip" ;;
    esac
  fi

  if [[ "${DNS_VAL}" != "${value}" || "${update}" -eq 1 ]]; then
    logger -t "${SCRIPT_NAME}" "Update required. (DNS=${DNS_VAL}, IP=${ip})"
    if [[ -n "${pre_update_cmd}" ]]; then
      debug_msg "${pre_update_cmd}"
      eval "${pre_update_cmd}"
    fi

    local commands="server ${server}
zone ${zone}
update delete ${fqdn%?} ${class} ${type}
update add ${fqdn%?} ${ttl_val} ${class} ${type} ${value}
"
    if [[ "${use_public_ip_target}" -eq 1 ]]; then
      commands+="update delete ${fqdn%?} ${class} TXT
update add ${fqdn%?} ${ttl_val} ${class} TXT \"$(date +%d.%m.%Y,\ %H:%M:%S\ %Z\ \(%:::z\))\"
"
    fi
    commands+="send
"
    debug_msg echo -e "${commands} | /usr/bin/nsupdate -k ${key}"
    echo -e "${commands}" | /usr/bin/nsupdate -k "${key}"

    local nsupdate_status=$?
    if [[ ${nsupdate_status} -ne 0 ]]; then
      log_status "[${RED}${CROSSMARK}${NC}] DNS update failed!" 1
      logger -t "${SCRIPT_NAME}" "DNS update failed! Wrong configuration?"
      return 1
    else
      log_status "[${GREEN}${CHECKMARK}${NC}] Updated to ${value}" 1
      logger -t "${SCRIPT_NAME}" "${fqdn%?} updated to ${value}."
    fi
  else
    print_aligned "DDNS-Status" "Update not necessary (DNS=${DNS_VAL}, IP=${ip})"
    logger -t "${SCRIPT_NAME}" "Update not necessary. (DNS=${DNS_VAL}, IP=${ip})"
  fi
}

dns_del_record() {
  checkpackage nsupdate dnsutils
  checkpackage dig dnsutils

  local record="$1"
  local zone="$2"

  # FQDN
  local fqdn
  if [[ "$record" == "@" ]]; then
    fqdn="${zone}."
  else
    fqdn="${record}.${zone}."
  fi

  local server="${dns_server}"
  local key="${dns_key}"
  local class="${dns_class}"

  check_key_permissions "$key"

  # Helper: check if EXACT RRset exists for this owner+type (normalize trailing dot + case)
  _has_rr_for_owner() {
    local name="$1" t="$2" srv="$3"
    local qname="${name%.}"
    local qtype="${t^^}"
    dig +noall +answer "${qtype}" "${qname}" @"${srv}" 2>/dev/null \
      | awk -v n="${qname,,}" -v T="${qtype}" '
          BEGIN { found=0 }
          {
            ow=$1; gsub(/\.$/, "", ow); ow=tolower(ow);
            tp=toupper($4);
            if (ow==n && tp==T) {found=1}
          }
          END { exit(found?0:1) }'
  }

  # Which types to check?
  local types_to_check=()
  if [[ "${record_type_was_explicit}" == "1" ]]; then
    types_to_check=("${record_type^^}")
  else
    types_to_check=(A AAAA CNAME MX NS SRV PTR CAA)
  fi

  # Collect existing types for this owner
  local detected_types=()
  local t
  for t in "${types_to_check[@]}"; do
    if _has_rr_for_owner "${fqdn%?}" "$t" "$server"; then
      detected_types+=("$t")
    fi
  done
  # TXT always considered
  if _has_rr_for_owner "${fqdn%?}" "TXT" "$server"; then
    local has_txt=0
    for t in "${detected_types[@]}"; do [[ "$t" == "TXT" ]] && has_txt=1 && break; done
    [[ $has_txt -eq 0 ]] && detected_types+=("TXT")
  fi

  if [[ ${#detected_types[@]} -eq 0 ]]; then
    log_status "[${YELLOW}!${NC}] No records present for ${fqdn}. Nothing to delete." 1
    return 0
  fi

  # Build one nsupdate transaction to delete all detected types
  local commands="server ${server}
zone ${zone}
"
  for t in "${detected_types[@]}"; do
    commands+="update delete ${fqdn%?} ${class} ${t}
"
  done
  commands+="send
"

  debug_msg echo -e "${commands} | /usr/bin/nsupdate -k ${key}"
  echo -e "${commands}" | /usr/bin/nsupdate -k "${key}"

  local nsupdate_status=$?
  if [[ ${nsupdate_status} -ne 0 ]]; then
    log_status "[${RED}${CROSSMARK}${NC}] DNS deletion failed for ${fqdn}" 1
    logger -t "${SCRIPT_NAME}" "DNS deletion failed! Wrong configuration?"
    return 1
  else
    local joined="$(printf "%s, " "${detected_types[@]}")"
    joined="${joined%, }"
    log_status "[${GREEN}${CHECKMARK}${NC}] ${joined} record(s) for ${fqdn} deleted" 1
    logger -t "${SCRIPT_NAME}" "${fqdn} ${joined} record(s) deleted."
  fi
}

# ----------------- Interactive mode -----------------
# Tab-aligned prompts; abort on empty input; force lowercase values
_prompt_req() {
  local idx="$1" label="$2" __outvar="$3" default_val="${4:-}"
  local prefix="${idx}. ${label}:"
  printf "%s" "$prefix"

  # Tighter target tab stop (~16 cols): two tabs
  local len=${#prefix}
  local target_tabs=2
  local current_tabs=$(( len / 8 ))
  local tabs_to_print=$(( target_tabs - current_tabs ))
  (( tabs_to_print < 1 )) && tabs_to_print=1
  for ((i=0;i<tabs_to_print;i++)); do printf "\t"; done

  read -r input
  if [[ -z "${input}" && -n "$default_val" ]]; then
    input="$default_val"
  fi
  if [[ -z "${input}" ]]; then
    echo -e "[${RED}${CROSSMARK}${NC}] Missing input for ${label}. Aborting."
    exit 64
  fi
  input="${input,,}"
  eval "$__outvar=\"\$input\""
}

_print_prompt_line() {
  local idx="$1" label="$2" value="$3"
  local prefix="${idx}. ${label}:"
  printf "%s" "$prefix"
  local len=${#prefix}
  local target_tabs=2
  local current_tabs=$(( len / 8 ))
  local tabs_to_print=$(( target_tabs - current_tabs ))
  (( tabs_to_print < 1 )) && tabs_to_print=1
  for ((i=0;i<tabs_to_print;i++)); do printf "\t"; done
  printf "%s\n" "$value"
}

interactive_dialog() {
  # prefer config for dns_server/dns_key; if -key was explicit, main already set dns_key accordingly
  : "${dns_server:=${DNS_SERVER:-}}"
  if [[ "${dns_key_was_explicit}" != "1" ]]; then
    dns_key="${DNS_KEY:-$dns_key}"
  fi
  : "${ip_detect_url:=${IP_DETECT_URL:-https://api.ipify.org}}"

  if [[ -z "$dns_server" || -z "$dns_key" ]]; then
    echo -e "[${RED}${CROSSMARK}${NC}] Missing DNS_SERVER or DNS_KEY in config (${GLOBAL_CONFIG} or ${USER_CONFIG})."
    echo "Please set DNS_SERVER=... and DNS_KEY=... in a config file (permissions 0600)."
    exit 67
  fi

  local action_in="${1:-}"
  local act
  if [[ -z "$action_in" ]]; then
    echo "Interactive mode:"
    echo "-----------------"
    _prompt_req "1" "Add/Del" act
    if [[ "$act" != "add" && "$act" != "del" ]]; then
      echo -e "[${RED}${CROSSMARK}${NC}] Unsupported action: $act"
      exit 65
    fi
  else
    act="${action_in,,}"
    echo "${SCRIPT_NAME} ${act} ..."
    _print_prompt_line "1" "Add/Del" "$act"
    if [[ "$act" != "add" && "$act" != "del" ]]; then
      echo -e "[${RED}${CROSSMARK}${NC}] Unsupported action: $act"
      exit 65
    fi
  fi

  local izone irecord itype itarget ittl

  case "$act" in
    add)
      _prompt_req "2" "DNS Zone" izone
      _prompt_req "3" "Record"   irecord
      _prompt_req "4" "Type"     itype   "${record_type,,}"
      _prompt_req "5" "Target"   itarget
      _prompt_req "6" "TTL"      ittl    "${ttl}"

      record_type="$itype"
      target_value="$itarget"
      ttl="$ittl"

      echo
      echo "\$ ${SCRIPT_NAME} add ${irecord} ${izone} -type ${itype} -target ${itarget} -ttl ${ittl}"
      echo
      dns_add_update "$irecord" "$izone"
      ;;
    del)
      _prompt_req "2" "DNS Zone" izone
      _prompt_req "3" "Record"   irecord

      echo
      echo "\$ ${SCRIPT_NAME} del ${irecord} ${izone}"
      echo
      dns_del_record "$irecord" "$izone"
      ;;
  esac
}

# --- Self-update ---
run_self_update() {
    checkpackage wget wget
    local self="$1"
    local update_base="$2"
    local script_path
    script_path=$(realpath "$0" 2>/dev/null || echo "$0")
    local script_name
    script_name=$(basename "$script_path")

    echo "Performing self-update"

    echo -ne "\r[ ] Downloading latest version..."
    if ! wget --quiet --output-document="${script_name}.tmp" "${update_base}/${self}"; then
        echo -e "\r[${RED}${CROSSMARK}${NC}] Downloading latest version"
        echo "[${RED}${CROSSMARK}${NC}] Performing self-update"
        exit 1
    fi
    echo -e "\r[${GREEN}${CHECKMARK}${NC}] Downloading latest version"

    echo -ne "\r[ ] Copying over modes from old version..."
    local octal_mode
    octal_mode=$(stat -c '%a' "$script_path" 2>/dev/null || echo "755")
    if ! chmod "$octal_mode" "${script_name}.tmp"; then
        echo -e "\r[${RED}${CROSSMARK}${NC}] Copying over modes from old version"
        echo "[${RED}${CROSSMARK}${NC}] Performing self-update"
        exit 1
    fi
    echo -e "\r[${GREEN}${CHECKMARK}${NC}] Copying over modes from old version"

    echo -ne "\r[ ] Start update process..."
    cat > updateScript.sh <<EOF
#!/bin/bash
if mv "${script_name}.tmp" "${script_path}"; then
    printf "\r\033[0KUpdate complete.\n"
    rm -f "\${0}"
else
    printf "\r\033[0KUpdate failed. Please try again!\n"
    rm -f "\${0}"
fi
EOF
    chmod +x updateScript.sh
    exec /bin/bash updateScript.sh
}

check_self_update() {
    local self
    self=$(basename "${0}")
    local update_base="${UPDATE_BASE:-https://to_be_set/}"  # keep trailing slash in UPDATE_BASE
    # Fetch only the first ~200 bytes from remote
    local remote_head
    remote_head=$(curl -fsS -r 0-200 "${update_base}${self}" | tr -d '\r' || true)

    # Parse versions from "Version=" lines
    local myself_web_version myself_local_version
    myself_web_version=$(printf '%s\n' "$remote_head" | awk -F= '/^# *Version=/{print $2; exit}')
    myself_local_version=$(head -n 3 "${0}" | tr -d '\r' | awk -F= '/^# *Version=/{print $2; exit}')

    if [[ -z "$myself_web_version" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] No online version found for ${self} at ${update_base}${self}." 1
        exit 1
    fi
    if [[ -z "$myself_local_version" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] Could not read local Version header from ${0}." 1
        exit 1
    fi

    printf "%-15s %s\n" "Web version:" "$myself_web_version"
    printf "%-15s %s\n" "Local version:" "$myself_local_version"

    if [[ "${myself_web_version}" > "${myself_local_version}" ]]; then
        echo -e "${YELLOW}New version v.${myself_local_version} to v.${myself_web_version} available.${NC}"
        read -p "Update [y/N] " -r
        echo
        if [[ ${REPLY:-N} =~ ^[Yy]$ ]]; then
            run_self_update "${self}" "${update_base}"
        fi
    else
        printf "%-15s v.%s\n" "No update available:" "${myself_local_version}"
    fi
}

main() {
  if [[ $# -lt 1 ]]; then
    usage
    exit 1
  fi

  # early single-shot flags
  case "${1:-}" in
    --help|-h)
      usage
      exit 0
      ;;
    -u)
      check_self_update
      exit 0
      ;;
  esac

  local action=""
  local record=""
  local zone=""

  # parse args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -dns-server) dns_server="${2:-}"; shift 2 ;;
      -key)        dns_key="${2:-}"; dns_key_was_explicit=1; shift 2 ;;
      -ip-detect)  ip_detect_url="${2:-}"; shift 2 ;;
      -type)       record_type="${2:-A}"; record_type_was_explicit=1; shift 2 ;;
      -ttl)        ttl="${2:-3600}"; shift 2 ;;
      -class)      dns_class="${2:-IN}"; shift 2 ;;
      -ipv4)       ip_version="ipv4"; shift ;;
      -ipv6)       ip_version="ipv6"; shift ;;
      -target-public-ip) use_public_ip_target=1; shift ;;
      -target)     target_value="${2:-}"; shift 2 ;;
      -v)          debug=1; shift ;;
      -y)          auto_overwrite_existing_records="y"; shift ;;
      -i)          interactive=1; shift ;;
      *)
        if [[ -z "$action" ]]; then
          action="$1"
        elif [[ -z "$record" ]]; then
          record="$1"
        elif [[ -z "$zone" ]]; then
          zone="$1"
        else
          usage
          exit 1
        fi
        shift
        ;;
    esac
  done

  # interactive flows
  if [[ "$interactive" == "1" && -z "$action" ]]; then
    interactive_dialog ""
    exit $?
  fi
  if [[ "$interactive" == "1" && -n "$action" ]]; then
    interactive_dialog "$action"
    exit $?
  fi

  # non-interactive: load defaults (config preferred)
  : "${dns_server:=${DNS_SERVER:-}}"
  : "${ip_detect_url:=${IP_DETECT_URL:-https://api.ipify.org}}"
  if [[ "${dns_key_was_explicit}" != "1" ]]; then
    dns_key="${DNS_KEY:-$dns_key}"
  fi

  # determine if this action needs an nsupdate key
  needs_key=0
  case "$action" in
    add|del|soa-set|soa-set-serial|soa-set-refresh|soa-set-retry|soa-set-expire|soa-set-minimum)
      needs_key=1
      ;;
  esac

  # require at least a server
  if [[ -z "${dns_server}" ]]; then
    usage
    exit 1
  fi

  # only require key for modifying actions
  if [[ "$needs_key" == "1" && -z "${dns_key}" ]]; then
    usage
    exit 1
  fi

  # install/check required tools per action
  if [[ "$needs_key" == "1" ]]; then
    checkpackage nsupdate dnsutils
  else
    checkpackage dig dnsutils
  fi

  case "$action" in
    add)              dns_add_update "$record" "$zone" ;;
    del)              dns_del_record "$record" "$zone" ;;
    check)            check_record "$record" "$zone" ;;
    soa-get)          get_zone_soa "$record" ;;
    soa-set)          set_zone_soa "$record" "$zone" "${3:-}" "${4:-}" "${5:-}" "${6:-}" "${7:-}" "${8:-}" ;;
    soa-set-serial)   set_zone_soa_serial "$record" "$zone" ;;
    soa-set-refresh)  set_zone_soa_refresh "$record" "$zone" ;;
    soa-set-retry)    set_zone_soa_retry "$record" "$zone" ;;
    soa-set-expire)   set_zone_soa_expire "$record" "$zone" ;;
    soa-set-minimum)  set_zone_soa_minimum "$record" "$zone" ;;
    listzone)         list_zone "$record" ;;
    listzone_full)    list_zone_full "$record" ;;
    *)
      usage
      exit 1
      ;;
  esac
}

main "$@"

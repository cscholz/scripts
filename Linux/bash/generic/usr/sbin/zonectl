#!/bin/bash
# Version=20251227.08
# Wrapper to manage dns zones
set -euo pipefail

# --- Colors / Styles ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m'
BOLD='\033[1m'
NOBOLD='\033[0m'

CHECKMARK="✓"
CROSSMARK="✗"

# --- Script / Config names ---
SCRIPT_NAME="$(basename "$0")"
CONFIG_NAME="${SCRIPT_NAME%.sh}.conf"
GLOBAL_CONFIG="/etc/${CONFIG_NAME}"
USER_CONFIG="$HOME/.config/${CONFIG_NAME}"

# --- Logging ---
log_status() {
    local msg="$1"
    local newline="${2:-0}" # 0=no newline; 1=newline
    if [[ "$newline" == "1" ]]; then
        echo -e "\r$msg"
    else
        echo -ne "\r$msg"
    fi
}

debug=0
debug_msg() {
    if [[ "$debug" == "1" ]]; then
        log_status "  ${YELLOW}\$ $*${NC}" 1
    fi
}

# --- Config permissions check (0600) ---
check_config_permissions() {
    local cfg="$1"
    if [[ -f "$cfg" ]]; then
        local mode
        mode=$(stat -c "%a" "$cfg")
        if [[ "$mode" != "600" ]]; then
            log_status "[${RED}${CROSSMARK}${NC}] Config file $cfg must have permissions 0600, but has $mode" 1
            exit 10
        fi
    fi
}

# --- Package check / optional install ---
checkpackage() {
  local exec="$1"
  local pkg="$2"
  if ! command -v "$exec" >/dev/null 2>&1; then
    echo -e "${RED}Package \"$pkg\" not found!${NC}"
    read -p "Install? (y/N) " -r
    if [[ ${REPLY:-N} =~ ^[Yy]$ ]]; then
      sudo apt-get update
      sudo apt-get install -y "$pkg"
    else
      exit 1
    fi
  fi
}

# --- Key permissions (0600) ---
check_key_permissions() {
  local keyfile="$1"
  if [[ ! -f "$keyfile" ]]; then
    echo -e "${RED}Key file does not exist: $keyfile${NC}"
    exit 1
  fi
  local perms
  perms=$(stat -c "%a" "$keyfile")
  if [[ "$perms" != "600" ]]; then
    echo -e "${RED}Key file $keyfile must have permissions 0600 (current: $perms). No updates performed!${NC}"
    exit 1
  fi
}

# --- Defaults (can be overridden by config and CLI) ---
dns_server=""
dns_key=""
ip_detect_url=""
record_type="A"
ttl="3600"
dns_class="IN"
ip_version="ipv4"
use_public_ip_target=0
target_value=""
pre_update_cmd=""
auto_overwrite_existing_records="n"
interactive=0
record_type_was_explicit=0
dns_key_was_explicit=0

# --- Load configs (global then user; user overrides) ---
check_config_permissions "$GLOBAL_CONFIG"
check_config_permissions "$USER_CONFIG"
[[ -f "$GLOBAL_CONFIG" ]] && source "$GLOBAL_CONFIG"
[[ -f "$USER_CONFIG"   ]] && source "$USER_CONFIG"

# --- Helpers ---
print_aligned() {
  local key="$1"
  local value="${2:-}"
  printf "%-15s %s\n" "$key:" "$value"
}

# --- Extract TLD robustly (handles .co.uk, .com, etc.) ---
extract_tld() {
    local domain="$1"
    # Remove trailing dot if present
    domain="${domain%.}"
    
    # Known two-part TLDs (extend as needed)
    local two_part_tlds="co.uk|org.uk|ac.uk|gov.uk|com.au|co.nz|co.za"
    
    if [[ "$domain" =~ \.($two_part_tlds)$ ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        # Single-part TLD (last segment)
        echo "${domain##*.}"
    fi
}

# --- Usage (original + only -i added) ---
usage() {
  echo -e "\033[1;4m1. Usage:\033[0m"
  echo "   ${SCRIPT_NAME} [Global Parameter] <command> [Parameter] [Arguments...]"
  echo
  echo -e "\033[1;4m2. Config:\033[0m"
  echo "   - /etc/${CONFIG_NAME} (global, system-wide)"
  echo "   - ~/.config/${CONFIG_NAME} (user-specific)"
  echo "   User config overrides global config."
  echo "   CLI parameters override both config files."
  echo
  echo -e "\033[1;4m3. Global Parameter:\033[0m"
  echo "   -u             Self-update"
  echo "   --help         Show this help"
  echo "   -v             Debug mode (show commands and variables in yellow)"
  echo "   -i             Interactive mode (guided prompts)"
  echo
  echo -e "\033[1;4m4. Commands:\033[0m"
  echo "   # Zone commands"
  echo "   soa-get <Zone>                           Show SOA record for the zone (nicely formatted)"
  echo "   soa-set <Zone> [primary] [email] [serial] [refresh] [retry] [expire] [minimum]"
  echo "                                            Set all SOA parameters for a zone. Old SOA will be replaced."
  echo "   soa-set-serial <Zone> <serial>           Update only the SOA serial for the zone"
  echo "   soa-set-refresh <Zone> <refresh>         Update only the SOA refresh value"
  echo "   soa-set-retry <Zone> <retry>             Update only the SOA retry value"
  echo "   soa-set-expire <Zone> <expire>           Update only the SOA expire value"
  echo "   soa-set-minimum <Zone> <minimum>         Update only the SOA minimum value"
  echo "   listzone <Zone>                          List all records of a DNS zone (zone transfer/AXFR, DNSSEC entries filtered)"
  echo "                                            Only the first dig output block is shown. DNSSEC (RRSIG/NSEC/DNSKEY) entries are excluded."
  echo "                                            Note: Only possible if the DNS server allows AXFR for your client IP."
  echo "   listzone_full <Zone>                     List all records of a DNS zone (zone transfer/AXFR, all records, no filtering)"
  echo
  echo "   # Record commands"
  echo "   add <Record Name> <Zone>                 Add or update a DNS record"
  echo "   del <Record Name> <Zone>                 Delete a DNS record"
  echo "   check <Record Name> <Zone>               Show DNS record and TXT record for a name"
  echo
  echo "   # Zone Health Checks"
  echo "   validate-dnssec <Zone>                   Validate DNSSEC chain (Root → TLD → Zone → Records)"
  echo "   check-serials <Zone>                     Check serial consistency across all NS/SOA servers"
  echo "   check-latency <Zone>                     Measure DNS response latency for all NS servers (5 queries each)"
  echo "   check-delegation <Zone>                  Compare NS records (Parent zone ↔ Zone) and verify reachability"
  echo "   check-glue <Zone>                        Show glue records (A/AAAA) from parent zone"
  echo
  echo -e "\033[1;4m5a. Zone Parameter:\033[0m"
  echo "   For soa-set and subcommands:"
  echo "     primary      Primary nameserver for the zone (default: ns1.<zone>.)"
  echo "     email        Email address for the zone (default: hostmaster.<zone>.)"
  echo "     serial       Serial number (default: YYYYMMDD01)"
  echo "     refresh      Refresh interval (default: 86400)"
  echo "     retry        Retry interval (default: 7200)"
  echo "     expire       Expire value (default: 3600000)"
  echo "     minimum      Minimum TTL (default: 172800)"
  echo
  echo -e "\033[1;4m5b. Zone Examples:\033[0m"
  echo "   1) \$ ${SCRIPT_NAME} soa-get example.com"
  echo "   2) \$ ${SCRIPT_NAME} soa-set example.com ns1.example.com. hostmaster.example.com. 2024062501 3600 600 86400 60"
  echo "   3) \$ ${SCRIPT_NAME} soa-set-serial example.com 2024062502"
  echo "   4) \$ ${SCRIPT_NAME} soa-set-refresh example.com 7200"
  echo "   5) \$ ${SCRIPT_NAME} listzone example.com"
  echo "   6) \$ ${SCRIPT_NAME} validate-dnssec example.com"
  echo "   7) \$ ${SCRIPT_NAME} check-serials example.com"
  echo "   8) \$ ${SCRIPT_NAME} check-delegation example.com"
  echo
  echo -e "\033[1;4m6a. Record Parameter:\033[0m"
  echo "   -dns-server <server>      DNS server to use (default from config)"
  echo "   -key <keyfile>            Path to nsupdate key (default from config)"
  echo "   -ip-detect <url>          URL to retrieve public IP (default: https://api.ipify.org)"
  echo "   -type <recordtype>        DNS record type (A, AAAA, MX, NS, TXT, etc.; default: A)"
  echo "   -ttl <seconds>            TTL for the record (default: 3600)"
  echo "   -class <class>            DNS class (default: IN)"
  echo "   -ipv4                     Use IPv4 (default)"
  echo "   -ipv6                     Use IPv6"
  echo "   -target-public-ip         Use your current public IP as the target value (A/AAAA)"
  echo "   -target <value>           Set target value for record (e.g. for MX, NS, TXT, CNAME, SRV, PTR)"
  echo "   -y                        Automatically overwrite existing records (default: n)"
  echo
  echo -e "\033[1;4m6b. Record Examples:\033[0m"
  echo "   1) dsl.example.com. 3600 IN A 203.0.113.42"
  echo "      \$ ${SCRIPT_NAME} add dsl example.com"
  echo
  echo "   2) dsl.example.com. 60 IN A 198.51.100.42"
  echo "      \$ ${SCRIPT_NAME} add dsl example.com -target-public-ip -ttl 60"
  echo
  echo "   3) spf.example.com. 3600 IN TXT \"v=spf1 include:_spf.example.com ~all\""
  echo "      \$ ${SCRIPT_NAME} add spf example.com -type TXT -target '\"v=spf1 include:_spf.example.com ~all\"'"
  echo
  echo "   4) www.example.com. 3600 IN CNAME example.com."
  echo "      \$ ${SCRIPT_NAME} add www example.com -type CNAME -ttl 3600 -class IN -dns-server ns1.example.com -key /root/${SCRIPT_NAME}.key -target \"example.com.\""
  echo
  echo "   5) example.com. 3600 IN MX 10 mail.example.com."
  echo "      \$ ${SCRIPT_NAME} add @ example.com -type MX -target \"10 mail.example.com.\""
  echo
}

# ============================================================================
# Zone Health Check Functions
# ============================================================================

validate_dnssec() {
    checkpackage delv bind9-dnsutils
    local zone="$1"
    
    echo "DNSSEC Validation for: ${zone}"
    echo "=========================================="
    echo ""
    
    # Use delv to validate DNSSEC chain
    debug_msg delv @127.0.0.1 +yaml "$zone"
    
    local output
    output=$(delv @127.0.0.1 +yaml "$zone" 2>&1 || true)
    
    # Colorize output for better readability
    echo "$output" | sed \
        -e "s,fully_validated,${GREEN}&${NC},g" \
        -e "s,unsigned_answer,${YELLOW}&${NC},g" \
        -e "s,negative_response_fully_validated,${RED}&${NC},g" \
        -e "s,validation_failed,${RED}&${NC},g" \
        -e "s,success,${GREEN}&${NC},g" \
        -e "s,nxdomain,${RED}&${NC},g" \
        -e "s,insecure,${YELLOW}&${NC},g"
    
    echo ""
    echo "=========================================="
    
    # Summary check
    if echo "$output" | grep -q "fully_validated"; then
        log_status "[${GREEN}${CHECKMARK}${NC}] DNSSEC validation successful" 1
    elif echo "$output" | grep -q "unsigned_answer"; then
        log_status "[${YELLOW}!${NC}] Zone is not signed with DNSSEC" 1
    else
        log_status "[${RED}${CROSSMARK}${NC}] DNSSEC validation failed" 1
    fi
}

check_serials() {
    checkpackage dig dnsutils
    local zone="$1"
    
    echo "Serial Consistency Check for: ${zone}"
    echo "=========================================="
    echo ""
    
    local highest_serial=0
    local serial_mismatches=0
    local has_cname_ns=0
    declare -A serial_map
    declare -A time_map
    declare -A type_map
    
    # Get all NS servers
    local ns_servers
    ns_servers=$(dig +short NS "$zone" @127.0.0.1 2>/dev/null | sed 's/\.$//' || true)
    
    if [[ -z "$ns_servers" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] No NS records found for zone ${zone}" 1
        return 1
    fi
    
    # Get SOA primary server
    local soa_primary
    soa_primary=$(dig +short SOA "$zone" @127.0.0.1 2>/dev/null | awk '{print $1}' | sed 's/\.$//' || true)
    
    # Collect all servers to check (NS + SOA primary)
    local all_servers
    all_servers=$(echo -e "$ns_servers\n$soa_primary" | sort -u | grep -v '^$')
    
    # First pass: collect all serials and find highest
    echo "Querying servers..."
    for server in $all_servers; do
        # Check if server is a CNAME (not recommended for NS)
        local cname_check
        cname_check=$(dig +short CNAME "$server" @127.0.0.1 2>/dev/null || true)
        if [[ -n "$cname_check" ]]; then
            has_cname_ns=1
        fi
        
        # Query for SOA to get serial
        debug_msg dig +time=6 SOA "$zone" @"$server"
        local dig_output
        dig_output=$(dig +time=6 SOA "$zone" @"$server" 2>/dev/null || true)
        
        local serial
        serial=$(echo "$dig_output" | grep -v ';' | grep SOA | grep -v 'NSEC' | head -n1 | awk '{print $7}')
        
        local query_time
        query_time=$(echo "$dig_output" | grep 'Query time:' | awk '{print $4 " " $5}')
        
        # Determine if this is NS or SOA server
        local server_type="NS "
        if [[ "$server" == "$soa_primary" ]]; then
            server_type="SOA"
        fi
        
        # Store results
        if [[ -n "$serial" && "$serial" -gt 0 ]]; then
            serial_map["$server"]="$serial"
            time_map["$server"]="$query_time"
            type_map["$server"]="$server_type"
            
            if [[ "$serial" -gt "$highest_serial" ]]; then
                highest_serial="$serial"
            fi
        else
            serial_map["$server"]="0"
            time_map["$server"]="n/a"
            type_map["$server"]="$server_type"
        fi
    done
    
    echo ""
    echo "Results:"
    echo "----------------------------------------"
    printf "%-12s  %-12s  %-4s  %-40s  %s\n" "Serial" "Query Time" "Type" "Server" "Status"
    echo "----------------------------------------"
    
    # Second pass: display results (show NS and SOA separately if server is both)
    for server in $all_servers; do
        local serial="${serial_map[$server]}"
        local query_time="${time_map[$server]}"
        local is_ns=0
        local is_soa=0
        
        # Check if server is NS
        if echo "$ns_servers" | grep -qx "$server"; then
            is_ns=1
        fi
        
        # Check if server is SOA primary
        if [[ "$server" == "$soa_primary" ]]; then
            is_soa=1
        fi
        
        # Output for SOA first (if applicable)
        if [[ "$is_soa" -eq 1 ]]; then
            if [[ "$serial" == "0" ]]; then
                printf "%-12s  %-12s  %-4s  %-40s  " "n/a" "$query_time" "SOA" "$server"
                echo -e "${RED}(unreachable)${NC}"
                serial_mismatches=$((serial_mismatches + 1))
            elif [[ "$serial" -lt "$highest_serial" ]]; then
                printf "%-12s  %-12s  %-4s  %-40s  " "$serial" "$query_time" "SOA" "$server"
                echo -e "${RED}(outdated)${NC}"
                serial_mismatches=$((serial_mismatches + 1))
            else
                printf "%-12s  %-12s  %-4s  %-40s  " "$serial" "$query_time" "SOA" "$server"
                echo -e "${GREEN}(ok)${NC}"
            fi
        fi
        
        # Output for NS (if applicable)
        if [[ "$is_ns" -eq 1 ]]; then
            if [[ "$serial" == "0" ]]; then
                printf "%-12s  %-12s  %-4s  %-40s  " "n/a" "$query_time" "NS " "$server"
                echo -e "${RED}(unreachable)${NC}"
                # Only increment once per server
                if [[ "$is_soa" -ne 1 ]]; then
                    serial_mismatches=$((serial_mismatches + 1))
                fi
            elif [[ "$serial" -lt "$highest_serial" ]]; then
                printf "%-12s  %-12s  %-4s  %-40s  " "$serial" "$query_time" "NS " "$server"
                echo -e "${RED}(outdated)${NC}"
                if [[ "$is_soa" -ne 1 ]]; then
                    serial_mismatches=$((serial_mismatches + 1))
                fi
            else
                printf "%-12s  %-12s  %-4s  %-40s  " "$serial" "$query_time" "NS " "$server"
                echo -e "${GREEN}(ok)${NC}"
            fi
        fi
    done
    
    echo "----------------------------------------"
    echo ""
    
    # Summary
    if [[ "$serial_mismatches" -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] All nameservers have the same serial: $highest_serial" 1
    else
        log_status "[${RED}${CROSSMARK}${NC}] Serial mismatch detected! $serial_mismatches server(s) outdated" 1
    fi
    
    if [[ "$has_cname_ns" -eq 1 ]]; then
        log_status "[${YELLOW}!${NC}] Warning: One or more NS records point to a CNAME (not recommended)" 1
    fi
}

check_latency() {
    checkpackage dig dnsutils
    local zone="$1"
    local iterations=5
    
    echo "DNS Latency Check for: ${zone}"
    echo "=========================================="
    echo ""
    
    # Get all NS servers
    local ns_servers
    ns_servers=$(dig +short NS "$zone" @127.0.0.1 2>/dev/null | sed 's/\.$//' || true)
    
    if [[ -z "$ns_servers" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] No NS records found for zone ${zone}" 1
        return 1
    fi
    
    declare -A latency_results
    
    echo "Measuring latency (${iterations} queries per server)..."
    echo ""
    
    # Process each server
    local server_count=0
    local total_servers=$(echo "$ns_servers" | wc -l)
    
    for server in $ns_servers; do
        server_count=$((server_count + 1))
        echo "[$server_count/$total_servers] ${server}"
        
        local total_time=0
        local successful_queries=0
        local min_time=999999
        local max_time=0
        
        for ((i=1; i<=iterations; i++)); do
            # Direct dig call with reasonable timeout (no background process)
            debug_msg dig +time=5 +tries=1 +retry=0 SOA "$zone" @"$server"
            
            local dig_output
            dig_output=$(dig +time=5 +tries=1 +retry=0 SOA "$zone" @"$server" 2>&1 || true)
            
            # Debug: show full output if debug mode enabled
            if [[ "$debug" == "1" ]]; then
                echo "=== DIG OUTPUT ===" >&2
                echo "$dig_output" >&2
                echo "=================" >&2
            fi
            
            # Parse query time - try multiple patterns for robustness
            local query_time=""
            
            # Method 1: Standard "Query time:" pattern (most common)
            if [[ -z "$query_time" ]]; then
                query_time=$(echo "$dig_output" | grep -i 'Query time:' | head -n1 | awk '{print $4}' | tr -d '\r\n' || echo "")
            fi
            
            # Method 2: Try with sed extraction
            if [[ -z "$query_time" ]]; then
                query_time=$(echo "$dig_output" | sed -n 's/.*Query time: *\([0-9]*\).*/\1/ip' | head -n1 || echo "")
            fi
            
            # Method 3: Try looking for msec pattern
            if [[ -z "$query_time" ]]; then
                query_time=$(echo "$dig_output" | grep -i 'msec' | grep -oE '[0-9]+' | head -n1 || echo "")
            fi
            
            # Debug: show extracted time
            if [[ "$debug" == "1" ]]; then
                echo "Extracted query_time: [$query_time]" >&2
            fi
            
            # Validate: must be a non-negative integer (0 is valid for cached/fast responses)
            if [[ -n "$query_time" ]] && [[ "$query_time" =~ ^[0-9]+$ ]]; then
                total_time=$((total_time + query_time))
                successful_queries=$((successful_queries + 1))
                
                if [[ "$query_time" -lt "$min_time" ]]; then
                    min_time="$query_time"
                fi
                
                if [[ "$query_time" -gt "$max_time" ]]; then
                    max_time="$query_time"
                fi
                
                if [[ "$debug" == "1" ]]; then
                    echo "SUCCESS: Recorded ${query_time}ms" >&2
                fi
            else
                if [[ "$debug" == "1" ]]; then
                    echo "FAILED: Could not parse valid query time" >&2
                fi
            fi
            
            # Small delay between queries to same server
            sleep 0.2
        done
        
        # Store results
        if [[ "$successful_queries" -gt 0 ]]; then
            local avg_time=$((total_time / successful_queries))
            latency_results["$server"]="${min_time}|${max_time}|${avg_time}|${successful_queries}"
        else
            latency_results["$server"]="0|0|0|0"
        fi
    done
    
    echo ""
    echo "Results:"
    echo "--------------------------------------------------------"
    printf "%-40s  %8s  %8s  %8s  %s\n" "Server" "Min (ms)" "Max (ms)" "Avg (ms)" "Success"
    echo "--------------------------------------------------------"
    
    # Sort by average latency (failed servers at end)
    for server in $(for s in $ns_servers; do
        local data="${latency_results[$s]}"
        local avg=$(echo "$data" | cut -d'|' -f3)
        # Put failed servers (avg=0) at the end
        if [[ "$avg" -eq 0 ]]; then
            avg=999999
        fi
        echo "$avg $s"
    done | sort -n | awk '{print $2}'); do
        
        local data="${latency_results[$server]}"
        local min=$(echo "$data" | cut -d'|' -f1)
        local max=$(echo "$data" | cut -d'|' -f2)
        local avg=$(echo "$data" | cut -d'|' -f3)
        local success=$(echo "$data" | cut -d'|' -f4)
        
        # Fix min value for display
        if [[ "$min" -eq 999999 ]]; then
            min=0
        fi
        
        # Output with color-coded success rate
        if [[ "$success" -eq "$iterations" ]]; then
            printf "%-40s  %8s  %8s  %8s  " "$server" "$min" "$max" "$avg"
            echo -e "${GREEN}${success}/${iterations}${NC}"
        elif [[ "$success" -gt 0 ]]; then
            printf "%-40s  %8s  %8s  %8s  " "$server" "$min" "$max" "$avg"
            echo -e "${YELLOW}${success}/${iterations}${NC}"
        else
            printf "%-40s  %8s  %8s  %8s  " "$server" "n/a" "n/a" "n/a"
            echo -e "${RED}${success}/${iterations}${NC}"
        fi
    done
    
    echo "--------------------------------------------------------"
}

check_delegation() {
    checkpackage dig dnsutils
    local zone="$1"
    
    echo "Delegation Check for: ${zone}"
    echo "=========================================="
    echo ""
    
    # Extract TLD robustly
    local tld
    tld=$(extract_tld "$zone")
    
    # Get root/parent NS for TLD
    local parent_ns
    parent_ns=$(dig +short NS "$tld" @127.0.0.1 2>/dev/null | head -n1 | sed 's/\.$//' || true)
    
    if [[ -z "$parent_ns" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] Could not find parent nameserver for TLD: ${tld}" 1
        return 1
    fi
    
    echo "Parent zone NS: ${parent_ns}"
    echo ""
    
    # Get NS records from parent zone
    debug_msg dig +time=6 NS "$zone" @"$parent_ns"
    local parent_ns_records
    parent_ns_records=$(dig +time=6 NS "$zone" @"$parent_ns" 2>/dev/null | grep -v ';' | grep NS | awk '{print $5}' | sed 's/\.$//' | sort || true)
    
    local parent_count
    parent_count=$(echo "$parent_ns_records" | grep -c '^' || echo "0")
    
    # Get NS records from zone itself
    debug_msg dig +time=6 +short NS "$zone" @127.0.0.1
    local zone_ns_records
    zone_ns_records=$(dig +time=6 +short NS "$zone" @127.0.0.1 2>/dev/null | sed 's/\.$//' | sort || true)
    
    local zone_count
    zone_count=$(echo "$zone_ns_records" | grep -c '^' || echo "0")
    
    # Compare counts
    echo "Comparing NS Records:"
    echo "----------------------------------------"
    
    if [[ "$parent_count" -eq "$zone_count" ]] && diff <(echo "$parent_ns_records") <(echo "$zone_ns_records") >/dev/null 2>&1; then
        echo -e "${GREEN}Parent NS Records ($parent_count):${NC}"
        echo "$parent_ns_records" | while read -r ns; do echo "  - $ns"; done
        echo ""
        echo -e "${GREEN}Zone NS Records ($zone_count):${NC}"
        echo "$zone_ns_records" | while read -r ns; do echo "  - $ns"; done
        echo ""
        log_status "[${GREEN}${CHECKMARK}${NC}] NS records match between parent and zone" 1
    else
        echo -e "${RED}Parent NS Records ($parent_count):${NC}"
        echo "$parent_ns_records" | while read -r ns; do echo "  - $ns"; done
        echo ""
        echo -e "${RED}Zone NS Records ($zone_count):${NC}"
        echo "$zone_ns_records" | while read -r ns; do echo "  - $ns"; done
        echo ""
        log_status "[${RED}${CROSSMARK}${NC}] NS record mismatch between parent and zone!" 1
    fi
    
    echo ""
    echo "Checking NS Reachability:"
    echo "----------------------------------------"
    
    # Check if NS servers are reachable
    for ns in $zone_ns_records; do
        debug_msg dig +time=3 +short A "$ns"
        local ip
        ip=$(dig +time=3 +short A "$ns" 2>/dev/null | head -n1 || true)
        
        if [[ -n "$ip" ]]; then
            # Try to query the NS
            debug_msg dig +time=3 SOA "$zone" @"$ns"
            if dig +time=3 SOA "$zone" @"$ns" >/dev/null 2>&1; then
                echo -e "  ${GREEN}${CHECKMARK}${NC} ${ns} (${ip}) - reachable"
            else
                echo -e "  ${RED}${CROSSMARK}${NC} ${ns} (${ip}) - not responding"
            fi
        else
            echo -e "  ${RED}${CROSSMARK}${NC} ${ns} - no A record found"
        fi
    done
}

check_glue() {
    checkpackage dig dnsutils
    local zone="$1"
    
    echo "Glue Record Check for: ${zone}"
    echo "=========================================="
    echo ""
    
    # Extract TLD robustly
    local tld
    tld=$(extract_tld "$zone")
    
    # Get root/parent NS for TLD
    local parent_ns
    parent_ns=$(dig +short NS "$tld" @127.0.0.1 2>/dev/null | head -n1 | sed 's/\.$//' || true)
    
    if [[ -z "$parent_ns" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] Could not find parent nameserver for TLD: ${tld}" 1
        return 1
    fi
    
    echo "Querying parent NS: ${parent_ns}"
    echo ""
    
    # Get glue records from parent zone (A and AAAA in additional section)
    debug_msg dig +time=6 NS "$zone" @"$parent_ns"
    local glue_output
    glue_output=$(dig +time=6 NS "$zone" @"$parent_ns" 2>/dev/null || true)
    
    local glue_records
    glue_records=$(echo "$glue_output" | grep -v ';' | grep -E '\sA\s|\sAAAA\s' | awk '{print $1 " " $4 " " $5}' || true)
    
    if [[ -n "$glue_records" ]]; then
        echo "Glue Records Found:"
        echo "----------------------------------------"
        echo "$glue_records" | while read -r name type value; do
            if [[ "$type" == "A" ]]; then
                echo -e "  ${GREEN}${name}${NC} → ${type} ${value}"
            elif [[ "$type" == "AAAA" ]]; then
                echo -e "  ${GREEN}${name}${NC} → ${type} ${value}"
            fi
        done
        echo ""
        log_status "[${GREEN}${CHECKMARK}${NC}] Glue records present in parent zone" 1
    else
        echo -e "${YELLOW}No glue records found in parent zone${NC}"
        echo ""
        
        # Check if glue records are needed
        local ns_servers
        ns_servers=$(dig +short NS "$zone" @127.0.0.1 2>/dev/null | sed 's/\.$//' || true)
        
        local needs_glue=0
        for ns in $ns_servers; do
            # Check if NS is within the zone (requires glue)
            if [[ "$ns" == *"${zone}"* ]]; then
                needs_glue=1
                echo -e "  ${YELLOW}!${NC} ${ns} is within zone ${zone} - glue record recommended"
            fi
        done
        
        if [[ "$needs_glue" -eq 1 ]]; then
            log_status "[${YELLOW}!${NC}] Warning: NS servers within zone require glue records!" 1
        else
            log_status "[${GREEN}${CHECKMARK}${NC}] No glue records needed (all NS servers outside zone)" 1
        fi
    fi
}

# ============================================================================
# Original Functions (unchanged)
# ============================================================================

get_zone_soa() {
    local zone="$1"
    local server="${dns_server}"
    checkpackage dig dnsutils
    debug_msg dig +short SOA "${zone}." @"${server}"
    local soa
    soa=$(dig +short SOA "${zone}." @"${server}" || true)
    if [[ -z "${soa}" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] No SOA record found for zone ${zone}." 1
        return 1
    fi
    local primary email serial refresh retry expire minimum
    read -r primary email serial refresh retry expire minimum <<<"$soa"
    printf "%-12s: %s\n" "Primary" "$primary"
    printf "%-12s: %s\n" "Email"   "$email"
    printf "%-12s: %s\n" "Serial"  "$serial"
    printf "%-12s: %s\n" "Refresh" "$refresh"
    printf "%-12s: %s\n" "Retry"   "$retry"
    printf "%-12s: %s\n" "Expire"  "$expire"
    printf "%-12s: %s\n" "Minimum" "$minimum"
}

set_zone_soa() {
    local zone="$1"
    local primary="${2:-}"
    local email="${3:-}"
    local serial="${4:-}"
    local refresh="${5:-}"
    local retry="${6:-}"
    local expire="${7:-}"
    local minimum="${8:-}"
    local server="${dns_server}"
    local key="${dns_key}"
    local class="IN"

    checkpackage nsupdate dnsutils
    [[ -z "$primary" ]] && primary="ns1.${zone}."
    [[ -z "$email"   ]] && email="hostmaster.${zone}."
    [[ -z "$serial"  ]] && serial="$(date +%Y%m%d)01"
    [[ -z "$refresh" ]] && refresh=86400
    [[ -z "$retry"   ]] && retry=7200
    [[ -z "$expire"  ]] && expire=3600000
    [[ -z "$minimum" ]] && minimum=172800

    local commands="server ${server}
zone ${zone}
update delete ${zone}. ${class} SOA
update add ${zone}. 3600 ${class} SOA ${primary} ${email} ${serial} ${refresh} ${retry} ${expire} ${minimum}
send
"
    debug_msg echo -e "${commands} | /usr/bin/nsupdate -k ${key}"
    echo -e "${commands}" | /usr/bin/nsupdate -k "${key}"

    if [[ $? -eq 0 ]]; then
        log_status "[${GREEN}${CHECKMARK}${NC}] SOA updated for zone ${zone}." 1
    else
        log_status "[${RED}${CROSSMARK}${NC}] SOA update failed for zone ${zone}." 1
        return 1
    fi
}

_set_from_existing_soa_and_apply() {
    local zone="$1" field="$2" value="$3"
    local server="${dns_server}"
    checkpackage dig dnsutils
    debug_msg dig +short SOA "${zone}." @"${server}"
    local old_soa primary email serial refresh retry expire minimum
    old_soa=$(dig +short SOA "${zone}." @"${server}" || true)
    [[ -z "$old_oa" && -z "$old_soa" ]] && { echo "No SOA found!"; return 1; }
    [[ -z "$old_soa" ]] && old_soa="$old_oa"
    read -r primary email serial refresh retry expire minimum <<<"$old_soa"
    case "$field" in
      serial)  serial="$value" ;;
      refresh) refresh="$value" ;;
      retry)   retry="$value" ;;
      expire)  expire="$value" ;;
      minimum) minimum="$value" ;;
    esac
    set_zone_soa "$zone" "$primary" "$email" "$serial" "$refresh" "$retry" "$expire" "$minimum"
}
set_zone_soa_serial()  { _set_from_existing_soa_and_apply "$1" "serial"  "$2"; }
set_zone_soa_refresh() { _set_from_existing_soa_and_apply "$1" "refresh" "$2"; }
set_zone_oa() { set_zone_soa "$@"; }  # typo-safe alias
set_zone_soa_retry()   { _set_from_existing_soa_and_apply "$1" "retry"   "$2"; }
set_zone_soa_expire()  { _set_from_existing_soa_and_apply "$1" "expire"  "$2"; }
set_zone_soa_minimum() { _set_from_existing_soa_and_apply "$1" "minimum" "$2"; }
_set_from_existing_oa_and_apply() { _set_from_existing_soa_and_apply "$@"; } # typo-safe alias

list_zone() {
  checkpackage dig dnsutils
  local zone="$1"
  local server="${dns_server}"
  echo "Attempting AXFR zone transfer for: $zone @ $server"
  echo "Note: This only works if the DNS server allows AXFR for your client IP."
  debug_msg dig "$zone" "AXFR" "@" "$server"
  dig "$zone" AXFR @"$server" | egrep -vi '(rrsig|nsec|dnskey)' | awk '!seen[$0]++'
}

list_zone_full() {
  checkpackage dig dnsutils
  local zone="$1"
  local server="${dns_server}"
  echo "Attempting AXFR zone transfer for: $zone @ $server"
  echo "Note: This only works if the DNS server allows AXFR for your client IP."
  debug_msg dig "$zone" "AXFR" "@" "$server"
  dig "$zone" AXFR @"$server" | awk '!seen[$0]++'
}

check_record() {
  checkpackage dig dnsutils
  local record="$1"
  local zone="$2"
  local fqdn
  if [[ "$record" == "@" ]]; then fqdn="${zone}"; else fqdn="${record}.${zone}"; fi
  local type="${record_type}"
  local server="${dns_server}"

  echo "Checking DNS records for: ${fqdn}."
  echo "-----------------------------------"
  print_aligned "$type" "$(dig "$type" "${fqdn}" @"${server}" +short 2>/dev/null | head -n1 || echo "n/a")"
  print_aligned "TXT"  "$(dig TXT "${fqdn}"  @"${server}" +short 2>/dev/null | head -n1 || echo "n/a")"
  echo "-----------------------------------"
}

dns_add_update() {
  checkpackage nsupdate dnsutils
  checkpackage curl curl
  local record="$1"
  local zone="$2"

  local fqdn
  if [[ "$record" == "@" ]]; then
    fqdn="${zone}."
  else
    fqdn="${record}.${zone}."
  fi
  local type="${record_type}"
  local server="${dns_server}"
  local key="${dns_key}"
  local url="${ip_detect_url:-https://api.ipify.org}"
  local ttl_val="${ttl}"
  local class="${dns_class}"
  local iptype="${ip_version}"
  local update=0

  check_key_permissions "$key"

  # Determine value
  local value=""
  local ip=""
  if [[ -n "${target_value}" ]]; then
    value="${target_value}"
  elif [[ "${use_public_ip_target}" -eq 1 || "$type" == "A" || "$type" == "AAAA" ]]; then
    local IPvX="4"
    if [[ "$type" == "AAAA" || "$iptype" == "ipv6" ]]; then IPvX="6"; fi
    debug_msg curl --connect-timeout 2 -"${IPvX}" --silent -f "${url}"
    ip=$(curl --connect-timeout 2 -"${IPvX}" --silent -f "${url}" || true)
    print_aligned "Public IPv${IPvX}" "${ip:-n/a}"
    if [[ -z "${ip}" ]]; then
      echo "Could not determine public IP. No internet connection?"
      logger -t "${SCRIPT_NAME}" "Could not determine public IP. No internet connection?"
      return 1
    fi
    value="$ip"
  fi

  echo "-----------------------------------------"
  print_aligned "DNS Zone"       "$zone"
  print_aligned "Record"         "$record"
  print_aligned "Type"           "$type"
  print_aligned "Class"          "$class"
  print_aligned "Target"         "$value"
  print_aligned "TTL"            "$ttl_val"
  print_aligned "FQDN"           "$fqdn"
  echo "-----------------------------------------"

  debug_msg dig "$type" "${fqdn%?}" "@" "$server" "+short"
  DNS_VAL=$(dig "$type" "${fqdn%?}" @"$server" +short 2>/dev/null || true)

  if [[ "${DNS_VAL}" == "${value}" && -n "${DNS_VAL}" ]]; then
    log_status "[-] Same target; not updated" 1
    return 0
  fi

  if [[ -n "${DNS_VAL}" ]]; then
    if [[ "$auto_overwrite_existing_records" == "y" ]]; then
      log_status "[ ] Deleting existing record..." 0
      local commands="server ${server}
zone ${zone}
update delete ${fqdn%?} ${class} ${type}
send
"
      debug_msg echo -e "${commands} | /usr/bin/nsupdate -k ${key}"
      echo -e "${commands}" | /usr/bin/nsupdate -k "${key}"
      log_status "\r[${GREEN}${CHECKMARK}${NC}] Deleting existing record" 1
      update=1
    else
      echo -en "${YELLOW}${BOLD}[?]${NOBOLD}${YELLOW}${NC} "
      read -p "Delete existing record before adding new one? (y/N) " -r
      if [[ ${REPLY:-N} =~ ^[Yy]$ ]]; then
        local commands="server ${server}
zone ${zone}
update delete ${fqdn%?} ${class} ${type}
send
"
        debug_msg echo -e "${commands} | /usr/bin/nsupdate -k ${key}"
        echo -e "${commands}" | /usr/bin/nsupdate -k "${key}"
        update=1
      else
        return 0
      fi
    fi
  fi

  if [[ -z "$value" ]]; then
    case "$type" in
      MX)   value="10 mail.${zone}." ;;
      NS)   value="ns1.${zone}." ;;
      TXT)  value="\"$(date +%d.%m.%Y,\ %H:%M:%S\ %Z\ \(%:::z\))\"" ;;
      CNAME)value="${zone}." ;;
      SRV)  value="10 60 5060 sipserver.${zone}." ;;
      PTR)  value="${zone}." ;;
      *)    value="$ip" ;;
    esac
  fi

  if [[ "${DNS_VAL}" != "${value}" || "${update}" -eq 1 ]]; then
    logger -t "${SCRIPT_NAME}" "Update required. (DNS=${DNS_VAL}, IP=${ip})"
    if [[ -n "${pre_update_cmd}" ]]; then
      debug_msg "${pre_update_cmd}"
      eval "${pre_update_cmd}"
    fi

    local commands="server ${server}
zone ${zone}
update delete ${fqdn%?} ${class} ${type}
update add ${fqdn%?} ${ttl_val} ${class} ${type} ${value}
"
    if [[ "${use_public_ip_target}" -eq 1 ]]; then
      commands+="update delete ${fqdn%?} ${class} TXT
update add ${fqdn%?} ${ttl_val} ${class} TXT \"$(date +%d.%m.%Y,\ %H:%M:%S\ %Z\ \(%:::z\))\"
"
    fi
    commands+="send
"
    debug_msg echo -e "${commands} | /usr/bin/nsupdate -k ${key}"
    echo -e "${commands}" | /usr/bin/nsupdate -k "${key}"

    local nsupdate_status=$?
    if [[ ${nsupdate_status} -ne 0 ]]; then
      log_status "[${RED}${CROSSMARK}${NC}] DNS update failed!" 1
      logger -t "${SCRIPT_NAME}" "DNS update failed! Wrong configuration?"
      return 1
    else
      log_status "[${GREEN}${CHECKMARK}${NC}] Updated to ${value}" 1
      logger -t "${SCRIPT_NAME}" "${fqdn%?} updated to ${value}."
    fi
  else
    print_aligned "DDNS-Status" "Update not necessary (DNS=${DNS_VAL}, IP=${ip})"
    logger -t "${SCRIPT_NAME}" "Update not necessary. (DNS=${DNS_VAL}, IP=${ip})"
  fi
}

dns_del_record() {
  checkpackage nsupdate dnsutils
  checkpackage dig dnsutils

  local record="$1"
  local zone="$2"

  # FQDN
  local fqdn
  if [[ "$record" == "@" ]]; then
    fqdn="${zone}."
  else
    fqdn="${record}.${zone}."
  fi

  local server="${dns_server}"
  local key="${dns_key}"
  local class="${dns_class}"

  check_key_permissions "$key"

  # Helper: check if EXACT RRset exists for this owner+type (normalize trailing dot + case)
  _has_rr_for_owner() {
    local name="$1" t="$2" srv="$3"
    local qname="${name%.}"
    local qtype="${t^^}"
    dig +noall +answer "${qtype}" "${qname}" @"${srv}" 2>/dev/null \
      | awk -v n="${qname,,}" -v T="${qtype}" '
          BEGIN { found=0 }
          {
            ow=$1; gsub(/\.$/, "", ow); ow=tolower(ow);
            tp=toupper($4);
            if (ow==n && tp==T) {found=1}
          }
          END { exit(found?0:1) }'
  }

  # Which types to check?
  local types_to_check=()
  if [[ "${record_type_was_explicit}" == "1" ]]; then
    types_to_check=("${record_type^^}")
  else
    types_to_check=(A AAAA CNAME MX NS SRV PTR CAA)
  fi

  # Collect existing types for this owner
  local detected_types=()
  local t
  for t in "${types_to_check[@]}"; do
    if _has_rr_for_owner "${fqdn%?}" "$t" "$server"; then
      detected_types+=("$t")
    fi
  done
  # TXT always considered
  if _has_rr_for_owner "${fqdn%?}" "TXT" "$server"; then
    local has_txt=0
    for t in "${detected_types[@]}"; do [[ "$t" == "TXT" ]] && has_txt=1 && break; done
    [[ $has_txt -eq 0 ]] && detected_types+=("TXT")
  fi

  if [[ ${#detected_types[@]} -eq 0 ]]; then
    log_status "[${YELLOW}!${NC}] No records present for ${fqdn}. Nothing to delete." 1
    return 0
  fi

  # Build one nsupdate transaction to delete all detected types
  local commands="server ${server}
zone ${zone}
"
  for t in "${detected_types[@]}"; do
    commands+="update delete ${fqdn%?} ${class} ${t}
"
  done
  commands+="send
"

  debug_msg echo -e "${commands} | /usr/bin/nsupdate -k ${key}"
  echo -e "${commands}" | /usr/bin/nsupdate -k "${key}"

  local nsupdate_status=$?
  if [[ ${nsupdate_status} -ne 0 ]]; then
    log_status "[${RED}${CROSSMARK}${NC}] DNS deletion failed for ${fqdn}" 1
    logger -t "${SCRIPT_NAME}" "DNS deletion failed! Wrong configuration?"
    return 1
  else
    local joined="$(printf "%s, " "${detected_types[@]}")"
    joined="${joined%, }"
    log_status "[${GREEN}${CHECKMARK}${NC}] ${joined} record(s) for ${fqdn} deleted" 1
    logger -t "${SCRIPT_NAME}" "${fqdn} ${joined} record(s) deleted."
  fi
}

# ----------------- Interactive mode -----------------
# Tab-aligned prompts; abort on empty input; force lowercase values
_prompt_req() {
  local idx="$1" label="$2" __outvar="$3" default_val="${4:-}"
  local prefix="${idx}. ${label}:"
  printf "%s" "$prefix"

  # Tighter target tab stop (~16 cols): two tabs
  local len=${#prefix}
  local target_tabs=2
  local current_tabs=$(( len / 8 ))
  local tabs_to_print=$(( target_tabs - current_tabs ))
  (( tabs_to_print < 1 )) && tabs_to_print=1
  for ((i=0;i<tabs_to_print;i++)); do printf "\t"; done

  read -r input
  if [[ -z "${input}" && -n "$default_val" ]]; then
    input="$default_val"
  fi
  if [[ -z "${input}" ]]; then
    echo -e "[${RED}${CROSSMARK}${NC}] Missing input for ${label}. Aborting."
    exit 64
  fi
  input="${input,,}"
  eval "$__outvar=\"\$input\""
}

_print_prompt_line() {
  local idx="$1" label="$2" value="$3"
  local prefix="${idx}. ${label}:"
  printf "%s" "$prefix"
  local len=${#prefix}
  local target_tabs=2
  local current_tabs=$(( len / 8 ))
  local tabs_to_print=$(( target_tabs - current_tabs ))
  (( tabs_to_print < 1 )) && tabs_to_print=1
  for ((i=0;i<tabs_to_print;i++)); do printf "\t"; done
  printf "%s\n" "$value"
}

interactive_dialog() {
  # prefer config for dns_server/dns_key; if -key was explicit, main already set dns_key accordingly
  : "${dns_server:=${DNS_SERVER:-}}"
  if [[ "${dns_key_was_explicit}" != "1" ]]; then
    dns_key="${DNS_KEY:-$dns_key}"
  fi
  : "${ip_detect_url:=${IP_DETECT_URL:-https://api.ipify.org}}"

  if [[ -z "$dns_server" || -z "$dns_key" ]]; then
    echo -e "[${RED}${CROSSMARK}${NC}] Missing DNS_SERVER or DNS_KEY in config (${GLOBAL_CONFIG} or ${USER_CONFIG})."
    echo "Please set DNS_SERVER=... and DNS_KEY=... in a config file (permissions 0600)."
    exit 67
  fi

  local action_in="${1:-}"
  local act
  if [[ -z "$action_in" ]]; then
    echo "Interactive mode:"
    echo "-----------------"
    _prompt_req "1" "Add/Del" act
    if [[ "$act" != "add" && "$act" != "del" ]]; then
      echo -e "[${RED}${CROSSMARK}${NC}] Unsupported action: $act"
      exit 65
    fi
  else
    act="${action_in,,}"
    echo "${SCRIPT_NAME} ${act} ..."
    _print_prompt_line "1" "Add/Del" "$act"
    if [[ "$act" != "add" && "$act" != "del" ]]; then
      echo -e "[${RED}${CROSSMARK}${NC}] Unsupported action: $act"
      exit 65
    fi
  fi

  local izone irecord itype itarget ittl

  case "$act" in
    add)
      _prompt_req "2" "DNS Zone" izone
      _prompt_req "3" "Record"   irecord
      _prompt_req "4" "Type"     itype   "${record_type,,}"
      _prompt_req "5" "Target"   itarget
      _prompt_req "6" "TTL"      ittl    "${ttl}"

      record_type="$itype"
      target_value="$itarget"
      ttl="$ittl"

      echo
      echo "\$ ${SCRIPT_NAME} add ${irecord} ${izone} -type ${itype} -target ${itarget} -ttl ${ittl}"
      echo
      dns_add_update "$irecord" "$izone"
      ;;
    del)
      _prompt_req "2" "DNS Zone" izone
      _prompt_req "3" "Record"   irecord

      echo
      echo "\$ ${SCRIPT_NAME} del ${irecord} ${izone}"
      echo
      dns_del_record "$irecord" "$izone"
      ;;
  esac
}

# --- Self-update ---
run_self_update() {
    checkpackage wget wget
    local self="$1"
    local update_base="$2"
    local script_path
    script_path=$(realpath "$0" 2>/dev/null || echo "$0")
    local script_name
    script_name=$(basename "$script_path")

    echo "Performing self-update"

    echo -ne "\r[ ] Downloading latest version..."
    if ! wget --quiet --output-document="${script_name}.tmp" "${update_base}/${self}"; then
        echo -e "\r[${RED}${CROSSMARK}${NC}] Downloading latest version"
        echo "[${RED}${CROSSMARK}${NC}] Performing self-update"
        exit 1
    fi
    echo -e "\r[${GREEN}${CHECKMARK}${NC}] Downloading latest version"

    echo -ne "\r[ ] Copying over modes from old version..."
    local octal_mode
    octal_mode=$(stat -c '%a' "$script_path" 2>/dev/null || echo "755")
    if ! chmod "$octal_mode" "${script_name}.tmp"; then
        echo -e "\r[${RED}${CROSSMARK}${NC}] Copying over modes from old version"
        echo "[${RED}${CROSSMARK}${NC}] Performing self-update"
        exit 1
    fi
    echo -e "\r[${GREEN}${CHECKMARK}${NC}] Copying over modes from old version"

    echo -ne "\r[ ] Start update process..."
    cat > updateScript.sh <<EOF
#!/bin/bash
if mv "${script_name}.tmp" "${script_path}"; then
    printf "\r\033[0KUpdate complete.\n"
    rm -f "\${0}"
else
    printf "\r\033[0KUpdate failed. Please try again!\n"
    rm -f "\${0}"
fi
EOF
    chmod +x updateScript.sh
    exec /bin/bash updateScript.sh
}

check_self_update() {
    local self
    self=$(basename "${0}")
    local update_base="${UPDATE_BASE:-https://to_be_set/}"  # keep trailing slash in UPDATE_BASE
    # Fetch only the first ~200 bytes from remote
    local remote_head
    remote_head=$(curl -fsS -r 0-200 "${update_base}${self}" | tr -d '\r' || true)

    # Parse versions from "Version=" lines
    local myself_web_version myself_local_version
    myself_web_version=$(printf '%s\n' "$remote_head" | awk -F= '/^# *Version=/{print $2; exit}')
    myself_local_version=$(head -n 3 "${0}" | tr -d '\r' | awk -F= '/^# *Version=/{print $2; exit}')

    if [[ -z "$myself_web_version" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] No online version found for ${self} at ${update_base}${self}." 1
        exit 1
    fi
    if [[ -z "$myself_local_version" ]]; then
        log_status "[${RED}${CROSSMARK}${NC}] Could not read local Version header from ${0}." 1
        exit 1
    fi

    printf "%-15s %s\n" "Web version:" "$myself_web_version"
    printf "%-15s %s\n" "Local version:" "$myself_local_version"

    if [[ "${myself_web_version}" > "${myself_local_version}" ]]; then
        echo -e "${YELLOW}New version v.${myself_local_version} to v.${myself_web_version} available.${NC}"
        read -p "Update [y/N] " -r
        echo
        if [[ ${REPLY:-N} =~ ^[Yy]$ ]]; then
            run_self_update "${self}" "${update_base}"
        fi
    else
        printf "%-15s v.%s\n" "No update available:" "${myself_local_version}"
    fi
}

main() {
  if [[ $# -lt 1 ]]; then
    usage
    exit 1
  fi

  # early single-shot flags
  case "${1:-}" in
    --help|-h)
      usage
      exit 0
      ;;
    -u)
      check_self_update
      exit 0
      ;;
  esac

  local action=""
  local record=""
  local zone=""

  # parse args
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -dns-server) dns_server="${2:-}"; shift 2 ;;
      -key)        dns_key="${2:-}"; dns_key_was_explicit=1; shift 2 ;;
      -ip-detect)  ip_detect_url="${2:-}"; shift 2 ;;
      -type)       record_type="${2:-A}"; record_type_was_explicit=1; shift 2 ;;
      -ttl)        ttl="${2:-3600}"; shift 2 ;;
      -class)      dns_class="${2:-IN}"; shift 2 ;;
      -ipv4)       ip_version="ipv4"; shift ;;
      -ipv6)       ip_version="ipv6"; shift ;;
      -target-public-ip) use_public_ip_target=1; shift ;;
      -target)     target_value="${2:-}"; shift 2 ;;
      -v)          debug=1; shift ;;
      -y)          auto_overwrite_existing_records="y"; shift ;;
      -i)          interactive=1; shift ;;
      *)
        if [[ -z "$action" ]]; then
          action="$1"
        elif [[ -z "$record" ]]; then
          record="$1"
        elif [[ -z "$zone" ]]; then
          zone="$1"
        else
          usage
          exit 1
        fi
        shift
        ;;
    esac
  done

  # interactive flows
  if [[ "$interactive" == "1" && -z "$action" ]]; then
    interactive_dialog ""
    exit $?
  fi
  if [[ "$interactive" == "1" && -n "$action" ]]; then
    interactive_dialog "$action"
    exit $?
  fi

  # non-interactive: load defaults (config preferred)
  : "${dns_server:=${DNS_SERVER:-}}"
  : "${ip_detect_url:=${IP_DETECT_URL:-https://api.ipify.org}}"
  if [[ "${dns_key_was_explicit}" != "1" ]]; then
    dns_key="${DNS_KEY:-$dns_key}"
  fi

  # determine if this action needs an nsupdate key
  needs_key=0
  case "$action" in
    add|del|soa-set|soa-set-serial|soa-set-refresh|soa-set-retry|soa-set-expire|soa-set-minimum)
      needs_key=1
      ;;
  esac

  # require at least a server
  if [[ -z "${dns_server}" ]]; then
    usage
    exit 1
  fi

  # only require key for modifying actions
  if [[ "$needs_key" == "1" && -z "${dns_key}" ]]; then
    usage
    exit 1
  fi

  # install/check required tools per action
  if [[ "$needs_key" == "1" ]]; then
    checkpackage nsupdate dnsutils
  else
    checkpackage dig dnsutils
  fi

  case "$action" in
    add)                dns_add_update "$record" "$zone" ;;
    del)                dns_del_record "$record" "$zone" ;;
    check)              check_record "$record" "$zone" ;;
    soa-get)            get_zone_soa "$record" ;;
    soa-set)            set_zone_soa "$record" "$zone" "${3:-}" "${4:-}" "${5:-}" "${6:-}" "${7:-}" "${8:-}" ;;
    soa-set-serial)     set_zone_soa_serial "$record" "$zone" ;;
    soa-set-refresh)    set_zone_soa_refresh "$record" "$zone" ;;
    soa-set-retry)      set_zone_soa_retry "$record" "$zone" ;;
    soa-set-expire)     set_zone_soa_expire "$record" "$zone" ;;
    soa-set-minimum)    set_zone_soa_minimum "$record" "$zone" ;;
    listzone)           list_zone "$record" ;;
    listzone_full)      list_zone_full "$record" ;;
    validate-dnssec)    validate_dnssec "$record" ;;
    check-serials)      check_serials "$record" ;;
    check-latency)      check_latency "$record" ;;
    check-delegation)   check_delegation "$record" ;;
    check-glue)         check_glue "$record" ;;
    *)
      usage
      exit 1
      ;;
  esac
}

main "$@"
